include ../_util-fns

:marked
  Our app is growing.
  Use cases are flowing in for reusing components, passing data to components, and creating more reusable assets. Let's separate the heroes list from the hero details and make the details component reusable.

  我们的应用继续成长。
  这次的例子将依次展示：复用组件、给组件传入数据、创建高复用度的软件资产。我们先把英雄列表从英雄详情中分离出来，并且让详情组件可被复用。
  
  [Run the live example for part 3](/resources/live-examples/toh-3/ts/plnkr.html)
  
  [运行第三部分的鲜活范例](/resources/live-examples/toh-3/ts/plnkr.html)

.l-main-section
:marked
  ## Where We Left Off
  ## 我们从哪里出发
  Before we continue with our Tour of Heroes, let’s verify we have the following structure. If not, we’ll need to go back and follow the previous chapters.
  
  在继续《英雄之旅》之前，我们先检查一下，完成第一部分之后，你是否已经有了如下目录结构。如果没有，你得先回到第一部分，看看缺了哪里。

.filetree
  .file angular2-tour-of-heroes
  .children
    .file app
    .children
      .file app.component.ts
      .file main.ts
    .file node_modules ...
    .file typings ...      
    .file index.html
    .file package.json
    .file tsconfig.json
    .file typings.json
:marked
  ### Keep the app transpiling and running
  ### 让应用代码保持转译和运行
  We want to start the TypeScript compiler, have it watch for changes, and start our server. We'll do this by typing

  我们要启动TypeScript编译器，它会监视文件变更，并且启动开发服务器。我们只要敲：

code-example(format="." language="bash").
  npm start

:marked
  This will keep the application running while we continue to build the Tour of Heroes.

  这个命令会在我们构建《英雄之旅》的时候让应用得以持续运行。

  ## Making a Hero Detail Component
  ## 制作英雄详情组件
  Our heroes list and our hero details are in the same component in the same file.
  They're small now but each could grow. 
  We are sure to receive new requirements for one and not the other.
  Yet every change puts both components at risk and doubles the testing burden without benefit.
  If we had to reuse the hero details elsewhere in our app,
  the heroes list would tag along for the ride. 
  
  我们的英雄列表和英雄详情目前位于同一个文件的同一个组件中。
  现在它们还很小，但很快它们都会长大。
  我们将来肯定会收到新需求：针对这一个，却不能影响另一个。
  然而，每一个更改都会给这两个组件带来风险，并且带来双倍的测试负担，却不会带来好处。
  如果我们不得不在此应用之外复用英雄详情组件，那么英雄列表组件也会跟着混进去。
  
  Our current component violates the 
  [Single Responsibility Principle](https://blog.8thlight.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html).
  It's only a tutorial but we can still do things right &mdash; 
  especially if doing them right is easy and we learn how to build Angular apps in the process.
  
  我们这个组件违反了[单一职责原则](https://blog.8thlight.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html)。
  虽然这只是一个教程，但我们还是要坚持做正确的事 —— 况且，做正确的事如此容易，我们何乐而不为呢？别忘了，我们正在学习的就是如何构建真正的Angular应用。
  
  Let’s break the hero details out into its own component.
  
  我们来把英雄详情拆分成一个独立的组件。

  ### Separating the Hero Detail Component
  ### 拆分英雄详情组件
  Add a new file named `hero-detail.component.ts` to the `app` folder and create `HeroDetailComponent` as follows.
  在`app`目录下添加一个名叫`hero-detail.component.ts`的文件，并且创建`HeroDetailComponent`。代码如下：

+makeExample('toh-3/ts/app/hero-detail.component.ts', 'v1', 'hero-detail.component.ts (初始版本)')(format=".")
.l-sub-section
  :marked
    ### Naming conventions
    ### 命名约定
    We like to identify at a glance which classes are components and which files contain components. 
    
    我们希望一眼就能看出哪个类是组件，以及哪个文件包含组件。
    
    Notice that  we have an `AppComponent` in a file named `app.component.ts` and our new
    `HeroDetailComponent` is in a file named `hero-detail.component.ts`. 
    
    注意，在名叫`app.component.ts`的文件中有一个`AppComponent`组件，在名叫`hero-detail.component.ts`的文件中有一个`HeroDetailComponent`组件。
    
    All of our component names end in "Component".  All of our component file names end in ".component".
    
    我们的所有组件名都以`Component`结尾。所有组件的文件名都以`.component`结尾。
    
    We spell our file names in lower dash case (AKA "kebab-case") so we don't worry about
    case sensitivity on the server or in source control.

    这里我们使用小写中线命名法（也叫烤串命名法），所以我们不用担心它在服务器或者版本控制系统中出现大小写问题。
    <!-- TODO
    .l-sub-section
      :marked
        Learn more about naming conventions in the chapter [Naming Conventions]
        
        要了解命名约定的更多知识，参见[命名约定]一章
    :marked
    -->
:marked
  We begin by importing the `Component` and `Input` decorators from Angular because we're going to need them soon.
  
  一开始，我们先从Angular中导入`Component`和`Input`装饰器，因为马上就会用到它们。
    
  We create metadata with the `@Component` decorator where we 
  specify the selector name that identifies this component's element.
  Then we export the class to make it available to other components.
  
  我们使用`@Component`装饰器创建元数据，在元数据中，我们指定选择器的名字，用以标记此组件的元素。
  然后，我们导出这个类，以便其他组件可以使用它。
  
  When we finish here, we'll import it into `AppComponent` and create a corresponding `<my-hero-detail>`  element.
  
  做完这些，我们把它导入`AppComponent`组件，并且创建相应的`<my-hero-detail>`元素。
:marked
  #### Hero Detail Template
  #### 英雄详情模板
  At the moment, the *Heroes* and *Hero Detail* views are combined in one template in `AppComponent`.
  Let’s **cut** the *Hero Detail* content from `AppComponent` and **paste** it into the new template property of  `HeroDetailComponent`.
  
  目前，在`AppComponent`中 *英雄列表* 和 *英雄详情* 视图被组合在同一个模板中。
  我们从`AppComponent`中 **剪切** 出 *英雄详情* 的内容，并且粘贴到`HeroDetailComponent`组件的`template`属性中。

  We previously bound to the `selectedHero.name` property of the `AppComponent`.
  Our `HeroDetailComponent` will have a `hero` property, not a `selectedHero` property.
  So we replace `selectedHero` with `hero` everywhere in our new template. That's our only change.
  The result looks like this:

  以前我们绑定到了`AppComponent`的`selectedHero.name`属性中。
  我们的`HeroDetailComponent`组件将会有一个`hero`属性，而不是`selectedHero`属性。
  所以，我们把模板中的所有`selectedHero`替换为`hero`。只要改这些就够了。
  最终结果如下所示：
+makeExample('toh-3/ts/app/hero-detail.component.ts', 'template', 'hero-detail.component.ts (模板)')(format=".")

:marked
  Now our hero detail layout exists only in the `HeroDetailComponent`.
  
  现在，我们的英雄详情布局只存在于`HeroDetailComponent`组件中。

  #### Add the *hero* property
  #### 添加 *hero* 属性
  Let’s add that `hero` property we were talking about to the component class.
  
  我们这就添加刚刚所说的`hero`属性到组件类中。
+makeExample('toh-3/ts/app/hero-detail.component.ts', 'hero')
:marked
  Uh oh. We declared the `hero` property as type `Hero` but our `Hero` class is over in the `app.component.ts` file. 
  We have two components, each in their own file, that need to reference the `Hero` class. 
  
  啊哦！我们定义的`hero`属性是`Hero`类型的，但是我们的`Hero`类还在`app.component.ts`文件中。
  我们有了两个组件，它们都有各自的文件，并且都需要引用`Hero`类。
  
  We solve the problem by relocating the `Hero` class from `app.component.ts` to its own `hero.ts` file.
  
  要想解决这个问题，我们也从`app.component.ts`文件中把`Hero`类移到属于它自己的`hero.ts`文件中。

+makeExample('toh-3/ts/app/hero.ts', null, 'hero.ts (导出Hero类)')(format=".")

:marked
  We export the `Hero` class from `hero.ts` because we'll need to reference it in both component files. 
  Add the following import statement near the top of both `app.component.ts` and `hero-detail.component.ts`.
  
  我们从`hero.ts`中导出`Hero`类，这是因为我们需要从这些组件文件中引用它。
  在`app.component.ts`和`hero-detail.component.ts`的顶部添加下列import语句：

+makeExample('toh-3/ts/app/hero-detail.component.ts', 'hero-import', 'hero-detail.component.ts与app.component.ts(导入Hero类)')

:marked
  #### The *hero* property is an ***input***
  #### *hero* 属性是一个 ***输入***
  
  The `HeroDetailComponent` must be told what hero to display. Who will tell it? The parent `AppComponent`! 
  
  The `AppComponent` knows which hero to show: the hero that the user selected from the list. 
  The user's selection is in its `selectedHero` property.
  
  We will soon update the `AppComponent` template so that it binds its `selectedHero` property
  to the `hero` property of our `HeroDetailComponent`. The binding *might* look like this:
code-example(format=".").
  &lt;my-hero-detail [hero]="selectedHero">&lt;/my-hero-detail>
:marked
  Notice that the `hero` property is the ***target*** of a property binding &mdash; it's in square brackets to the left of the (=).
  
  Angular insists that we declare a ***target*** property to be an ***input*** property.
  If we don't, Angular rejects the binding and throws an error.
.l-sub-section
  :marked
    We explain input properties in more detail [here](../guide/attribute-directives.html#why-input) 
    where we also explain why *target* properties require this special treament and 
    *source* properties do not.
:marked
  There are a couple of ways we can declare that `hero` is an *input*. 
  We'll do it the way we *prefer*, by annotating the `hero` property with the `@Input` decorator that we imported earlier.
+makeExample('toh-3/ts/app/hero-detail.component.ts', 'hero-input')(format='.')
  
.l-sub-section
  :marked
    Learn more about the `@Input()` decorator in the 
    [Attribute Directives](../guide/attribute-directives.html#input) chapter.

.l-main-section
:marked
  ## Refresh the AppComponent
  We return to the `AppComponent` and teach it to use the `HeroDetailComponent`.

  We begin by importing the `HeroDetailComponent` so we can refer to it.

+makeExample('toh-3/ts/app/app.component.ts', 'hero-detail-import')

:marked
  Find the location in the template where we removed the *Hero Detail* content
  and add an element tag that represents the `HeroDetailComponent`.
code-example(format=".").
  &lt;my-hero-detail>&lt;/my-hero-detail>
.l-sub-section
  :marked
    *my-hero-detail* is the name we set as the  `selector` in the `HeroDetailComponent` metadata.
:marked
 The two components won't coordinate until we bind the `selectedHero` property of the `AppComponent` 
 to the `HeroDetailComponent` element's `hero` property  like this:
code-example(format=".")
  &lt;my-hero-detail [hero]="selectedHero">&lt;/my-hero-detail>
:marked
  The `AppComponent`’s template should now look like this

+makeExample('toh-3/ts/app/app.component.ts', 'hero-detail-template', 'app.component.ts (Template)')
:marked
  Thanks to the binding, the `HeroDetailComponent` should receive the hero from the `AppComponent` and display that hero's detail beneath the list.
  The detail should update every time the user picks a new hero.
  
  It's not happening yet!
  
  We click among the heroes. No details. We look for an error in the console of the browser development tools. No error.
  
  It is as if Angular were ignoring the new tag. That's because *it is ignoring the new tag*.
  
  ### The *directives* array
  A browser ignores HTML tags and attributes that it doesn't recognize. So does Angular.
  
  We've imported `HeroDetailComponent`, we've used it in the template, but we haven't told Angular about it.
  
  We tell Angular about it by listing it in the metadata `directives` array. Let's add that array property to the bottom of the
  `@Component` configuration object, immediately after the `template` and `styles` properties.
+makeExample('toh-3/ts/app/app.component.ts', 'directives')


:marked
  ### It works!
  When we view our app in the browser we see the list of heroes. 
  When we select a hero we can see the selected hero’s details. 
  
  What's fundamentally new is that we can use this `HeroDetailComponent`
  to show hero details anywhere in the app.

  We’ve created our first reusable component!

  ### Reviewing the App Structure
  Let’s verify that we have the following structure after all of our good refactoring in this chapter:

.filetree
  .file angular2-tour-of-heroes
  .children
    .file app
    .children
      .file app.component.ts
      .file hero.ts
      .file hero-detail.component.ts
      .file main.ts
    .file node_modules ...
    .file typings ...      
    .file index.html
    .file package.json
    .file tsconfig.json
    .file typings.json
:marked
  Here are the code files we discussed in this chapter.

+makeTabs(`
  toh-3/ts/app/hero-detail.component.ts,
  toh-3/ts/app/app.component.ts,
  toh-3/ts/app/hero.ts
  `,'',`
  app/hero-detail.component.ts,
  app/app.component.ts,
  app/hero.ts
  `)

.l-main-section
:marked
  ## The Road We’ve Travelled
  Let’s take stock of what we’ve built.

  * We created a reusable component
  * We learned how to make a component accept input
  * We learned to bind a parent component to a child component.
  * We learned to declare the application directives we need in a `directives` array.

  [Run the live example for part 3](/resources/live-examples/toh-3/ts/plnkr.html).

.l-main-section
:marked
  ## The Road Ahead
  Our Tour of Heroes has become more reusable with shared components. 
  
  We're still getting our (mock) data within the `AppComponent`.
  That's not sustainable. 
  We should refactor data access to a separate service
  and share it among the components that need data. 
  
  We’ll learn to create services in the [next tutorial](toh-pt4.html) chapter.
