include _util-fns

// #docregion intro
:marked
  # Angular 2词汇表

  Angular 2 has a vocabulary of its own.
  Most Angular 2 terms are everyday English words
  with a specific meaning within the Angular system.

  Angular 2有自己的词汇表。
  虽然大多数的Angular 2短语都是日常用语，但是在Angular体系中，它们有特别的含义。

  We have gathered here the most prominent terms
  and a few less familiar ones that have unusual or
  unexpected definitions.

  我们搜集了常用词和少量具有独特或反直觉含义的罕用词。

  [A](#A) [B](#B) [C](#C) [D](#D) [E](#E) [F](#F) [G](#G) [H](#H) [I](#I)
  [J](#J) [K](#K) [L](#L) [M](#M) [N](#N) [O](#O) [P](#P) [Q](#Q) [R](#R)
  [S](#S) [T](#T) [U](#U) [V](#V) [W](#W) [X](#X) [Y](#Y) [Z](#Z)
// #enddocregion intro

// #docregion a1
<a id="A"></a>
// #enddocregion a1
.l-main-section
:marked
  ## Annotation
  ## 注解（Annotation）
.l-sub-section
  :marked
    In practice a synonym for [Decoration](#decorator).
    
    [装饰器（Decoration）](#decorator)在实践中的同义词。
// #enddocregion a-1
// #docregion a-2
:marked
  ## Attribute Directive
  ## 属性型指令（Attribute Directive）
.l-sub-section
  :marked
    A category of [Directive](#directive) that can listen to and modify the behavior of
    other HTML elements, attributes, properties, and components. They are usually represented
    as HTML attributes, hence the name.

    [指令](#directive)分类中的一种。它允许监听或修改其它HTML元素、属性、组件的行为。它们通常用作HTML属性，就像它的名字所暗示的那样。
    
    The `ngClass` directive for adding and removing CSS class names is a good example of
    an Attribute Directive.
    
    `ngClass`指令就是典型的属性型指令。它可以添加或移除CSS类名。
// #enddocregion a-2

// #docregion b-c
- var lang = current.path[1]
- var decorator = lang === 'dart' ? 'annotation' : '<a href="#decorator">decorator</a>'
- var atSym = lang === 'js' ? '' : '@'
<a id="B"></a>
.l-main-section
:marked
  ## Barrel
  ## 封装桶（Barrel）
.l-sub-section
  :marked
    A **barrel** is an Angular library module consisting of a logical grouping of single-purpose modules
    such as `Component` and `Directive`.

    一个**封装桶**是一个模块库，由单一用途的多个模块，比如组件和指令等组成。

    Familiar barrels include `angular2/core`, `angular2/common`, `angular2/platform/browser`,
    `angular2/http`, and `angular2/router`.

    你熟悉的封装桶包含`angular2/core`, `angular2/common`, `angular2/platform/browser`,
       `angular2/http`, 和 `angular2/router`.

    Barrels are packaged and shipped as [**bundles**](#bundle) that
    we may load with script tags in our `index.html`.

    封装桶被当做[**捆绑包bundles**](#bundle)打包和发布，以便我们通过Script标签在`index.html`页面里面装载。

    The script, `angular2.dev.js`, is a bundle.
    `angular2.dev.js`脚本就是一个捆绑包（bundle）

    Learn more in "[Modules, barrels and bundles](https://github.com/angular/angular/blob/master/modules/angular2/docs/bundles/overview.md)".
    
    获取更多关于模块，封装桶和捆绑包的信息："[Modules, barrels and bundles](https://github.com/angular/angular/blob/master/modules/angular2/docs/bundles/overview.md)"
    
:marked
  ## Binding
  ## 绑定
.l-sub-section
  :marked
    Almost always refers to [Data Binding](#data-binding) and the act of
    binding an HTML object property to a data object property.

    几乎都是指的[数据绑定](#data-binding)和将一个HTML对象属性绑定到一个数据对象属性的行为。

    May refer to a [Dependency Injection](#dependency-injection) binding
    between a "token" or "key" and a dependency [provider](#provider).
    This more rare usage should be clear in context.

    有可能指的是[依赖注入](#dependency-injection)在一个记号(Token)或键值(Key)和一个依赖[Provider](#provider)之间的绑定。
    这个用法很少，而且一般都应该在上下文中明确标示。

:marked
  ## Bootstrap
  ## 引导程序
.l-sub-section
  :marked
    We launch an Angular application by "bootstrapping" it with the `bootstrap` method.
    The `bootstrap` method identifies an application's top level "root" [Component](#component)
    and optionally registers service [providers](#provider) with the
    [dependency injection system](#dependency-injection).

    我们通过一个名叫`bootstrap`的类方法来引导装入Angular应用程序。这个`bootstrap`类方法会识别应用程序的顶级“根”[组件](#component)，
    并可能通过[依赖注入系统](#dependency-injection)注册服务[Provider](#provider)。

    One can bootstrap multiple apps in the same `index.html`, each with its own top level root.
    你可以在同一个`index.html`启动多个程序，每个程序都有自己的顶级根组件。

:marked
  ## Bundle
  ## 捆绑包
.l-sub-section
  :marked
    Angular JavaScript libraries are shipped in **bundles** within an **npm package**
    such as [angular2](https://www.npmjs.com/package/angular2).

    Angular Javascript库是以将多个**捆绑包**（**bundles**）捆绑到一起，以一个**NPM包**（**npm package**）的形式发布的。
    比如[angular2](https://www.npmjs.com/package/angular2).

    The scripts `angular2.dev.js`, `http.js`, `router.js`, and `Rx.js` are
    familiar examples of bundles.

    `angular2.dev.js`, `http.js`, `router.js`, 和 `Rx.js`等脚本文件是比较常见的捆绑包（bundle）例子。


    A bundle contains one more more [**barrels**](#barrel)
    and each barrel contains a collection of logically related [modules](#module)

    一个捆绑包（bundle）包含了一个或多个[**封装桶**](#barrel)

    Familiar barrels include `angular2/core`, `angular2/common`, `angular2/platform/browser`,
    `angular2/http`, `angular2/router`.

    常见的封装桶包括`angular2/core`, `angular2/common`, `angular2/platform/browser`,
        `angular2/http`, `angular2/router`等。

    Learn more in "[Modules, barrels and bundles](https://github.com/angular/angular/blob/master/modules/angular2/docs/bundles/overview.md)".
    
    获取更多关于模块，封装桶和捆绑包的知识："[模块，封装桶和捆绑包](https://github.com/angular/angular/blob/master/modules/angular2/docs/bundles/overview.md)"。

<a id="C"></a>
.l-main-section
:marked
  ## camelCase
  ## 驼峰式命名法
.l-sub-section
  :marked
    The practice of writing compound words or phrases such that each word or abbreviation begins with a capital letter 
    _except the first letter which is a lowercase letter_. 

    驼峰式命名法是除了首字母小写外，每一个单词或简写以大写字母开始编写词汇或短语的实践方法。

    Function, property, and method names are typically spelled in camelCase. Examples include: `square`, `firstName` and `getHeroes`.

    函数、属性和方法命名一般都使用驼峰式大小写命名法。比如`square`, `firstName` 和 `getHeroes`等。

    This form is also known as **lower camel case**, to distinguish it from **upper camel case** which we call [PascalCase](#pascalcase).
    When we write "camelCase" in this documentation we always mean *lower camel case*.

    这种形式也被叫做**小驼峰式命名法**（**lower camel case**），以便区分**大驼峰式命名法**（我们也叫帕斯卡命名法）。
    当我们文档中提到“驼峰式命名法” （“camelCase”）的时候，所指的都是小驼峰命名法。

:marked
  ## Component
  ## 组件
.l-sub-section
  :marked
    An Angular class responsible for exposing data
    to a [View](#view) and handling most of the view’s display
    and user-interaction logic.

    组件是一个用来展示数据到[视图](#view)，并处理几乎所有视图显示以及用户交互逻辑的Angular类（Angular Class）。

    The Component is one of the most important building blocks in the Angular system.
    It is, in fact, an Angular [Directive](#directive) with a companion [Template](#template).

    组件是Angular系统的最重要的基本单位之一。
    它其实是一个拥有[模板](#template)的[指令](#directive)。

    The  developer applies the `#{atSym}Component` !{decorator} to
    the component class, thereby attaching to the class the essential component metadata
    that Angular needs to create a component instance and render it with its template
    as a view.

    开发人员在使用`#{atSym}Component`!{decorator}来装饰一个组件类，就是把这个类附加到核心组件元数据（essential component metadata）上面。
    Angular利用这个核心组件的元数据信息，来建立一个组件实例，并把组件的模板作为视图渲染出来。

    Those familiar with "MVC" and "MVVM" patterns will recognize
    the Component in the role of "Controller" or "View Model".

    那些熟悉 "MVC" 和 "MVVM" 架构模式的应该能意识到组件充当了控制和视图模型的角色。
// #enddocregion b-c

// #docregion d1
<a id="D"></a>
.l-main-section
:marked
  ## dash-case
  ## 中线命名法
.l-sub-section
  :marked
    The practice of writing compound words or phrases such that each word is separated by a dash or hyphen (-). 

    使用中线来分隔每个单词来编写词汇或短语的方法叫做中线命名法（dash-case）。

    Directive selectors and the root of filenames are often spelled in dash-case. Examples include: `my-app` and the `hero-list.component.ts`.

    指令的选择器和文件名通常都是通过中线命名法来命名的。比如`my-app` 和 `hero-list.component.ts`。

    This form is also known as [kebab-case](#kebab-case).

    这种命名法也被称为烤串命名法[kebab-case](#kebab-case)。

:marked
  ## Data Binding
  ## 数据绑定
.l-sub-section
  :marked
    Applications display data values to a user and respond to user
    actions (clicks, touches, keystrokes).

    应用程序一般将数据展示给用户，并对用户的操作（点击、触屏、按键）做出回应。
    
    We could push application data values into HTML, attach
    event listeners, pull changed values from the screen, and
    update application data values ... all by hand.
    
    我们可以自己处理这些操作：将数据显示到HTML网页，添加事件监听器，从屏幕获取数据变化，然后更新数据等等。。。

    Or we could declare the relationship between an HTML widget
    and an application data source ... and let a data binding
    framework handle the details.
    
    或者，我们可以声明HTML小部件和数据源的关系...，让一个数据绑定框架工具来处理所有细节。

    Data Binding is that second approach. Angular has a rich
    data binding framework with a variety of data binding
    operations and supporting declaration syntax.
    
    数据绑定是第二种方法。Angular有一个非常强大的数据绑定框架工具，具有多种用来数据绑定的操作，并支持声明语法规则。

     The many forms of binding include:
     * [Interpolation](guide/template-syntax.html#interpolation)
     * [Property Binding](guide/template-syntax.html#property-binding)
     * [Event Binding](guide/template-syntax.html#event-binding)
     * [Attribute Binding](guide/template-syntax.html#attribute-binding)
     * [Class Binding](guide/template-syntax.html#class-binding)
     * [Style Binding](guide/template-syntax.html#style-binding)
     * [Two-way data binding with ngModel](guide/template-syntax.html#ng-model)

     绑定模式包括：
     * [插值Interpolation](guide/template-syntax.html#interpolation)
     * [属性绑定Property Binding](guide/template-syntax.html#property-binding)
     * [事件绑定Event Binding](guide/template-syntax.html#event-binding)
     * [特征绑定Attribute Binding](guide/template-syntax.html#attribute-binding)
     * [类绑定Class Binding](guide/template-syntax.html#class-binding)
     * [样式绑定Style Binding](guide/template-syntax.html#style-binding)
     * [使用ngModel进行双向数据绑定Two-way data binding with ngModel](guide/template-syntax.html#ng-model)
     
    Learn more about data binding in the
    [Template Syntax](guide/template-syntax.html#data-binding) chapter.
    
    到[模板语法](guide/template-syntax.html#data-binding)章节获取更多关于数据绑定的知识。

// #enddocregion d1
<a id="decorator"></a> <a id="decoration"></a>
:marked
  ## Decorator | Decoration
  ## 装饰器
.l-sub-section
  :marked
    A Decorator is a **function** that adds metadata to a class, its members (properties, methods) and function arguments.
    
    一个装饰器是一个**函数**，这个函数将元数据添加到一个类、类成员（属性、方法）和函数上。
    
    Decorators are a JavaScript language [feature](https://github.com/wycats/javascript-decorators), implemented in TypeScript and proposed for ES2016 (AKA ES7).
    
    装饰器是一个Javascript的语言[特征](https://github.com/wycats/javascript-decorators)，装饰器在TypeScript里面已经采用并实施了，它也被推荐到ES2016（也就是ES7）

    We apply a decorator by positioning it
    immediately above or to the left of the thing it decorates.
    
    我们应用装饰器的方法是把装饰器放到被装饰的对象的上面或者左边。

    Angular has its own set of decorators to help it interoperate with our application parts.
    Here is an example of a `@Component` decorator that identifies a
    class as an Angular [Component](#component) and an `@Input` decorator applied to a property
    of that component.
    
    Angular使用一套自己的装饰器来实现应用程序的各部分的相互操作。
    下面的例子是一个使用`@Component`装饰器来将一个类标示为一个Angular[组件](#component)，并使用`@Input`装饰器装饰这个组件的一个属性。
    
    The elided object argument to the `@Component` decorator would contain the pertinent component metadata.
    
    被省略的`@Component`装饰器的参数对象可能包含了相关的组件元数据。
    
    ```
    @Component({...})
    export class AppComponent {
      constructor(@Inject('SpecialFoo') public foo:Foo) {}
      @Input()
      name:string;
    }
    ```
    The scope of a decorator is limited to the language feature
    that it decorates. None of the decorations shown here will "leak" to other
    classes appearing below it in the file.
    
    一个装饰器的作用范围会被限制在被装饰的作用范围之内。在以上的例子中，没有一个装饰器会“泄露”到其他类，就算这些其他类在同一个文件紧跟着上面的类。
    

  .alert.is-important
    :marked
      Always include the parentheses `()` when applying a decorator.
      A decorator is a **function** that must be called when applied.
      
      总是在装饰器后面加包括`()`。因为装饰器是**函数**，在装饰的时候一定会被运行。

// #docregion d2
:marked
  ## Dependency Injection
  ## 依赖注入
.l-sub-section
  :marked
    Dependency Injection is both a design pattern and a mechanism
    for creating and delivering parts of an application to other
    parts of an application that request them.
    
    依赖注入既是设计模式，同时也是一种机制：当应用程序的一些部件需要另一些部件的时候，使用依赖注入机制来新建被请求的部件并将其注入到发出请求的部件。

    Angular developers prefer to build applications by defining many simple parts
    that each do one thing well and then wire them together at runtime.
    
    Angular开发者比较倾向的开发应用程序的方法是，定义许多精简小部件，每个小部件只做一件事并做好自己那件事，然后在运行时间把这些精简小部件连在一起组成应用程序。

    These parts often rely on other parts. An Angular [Component](#component)
    part might rely on a service part to get data or perform a calculation. When a
    part "A" relies on another part "B", we say that "A" depends on "B" and
    that "B" is a dependency of "A".
    
    这些小部件通常依赖其他小部件。一个Angular[组件](#component)可能依赖一个服务部件来获取数据或者处理运算。当部件A依赖部件B，我们说A依赖B，B是A的“依赖”。

    We can ask a "Dependency Injection System" to create "A"
    for us and handle all the dependencies.
    If "A" needs "B" and "B" needs "C", the system resolves that chain of dependencies
    and returns a fully prepared instance of "A".
    
    我们可以让“依赖注入系统”为我们新建一个部件A并处理所有A的“依赖”。如果A需要B，B需要C，这个系统便解析这个依赖链，返回给我们一个完整准备妥当的A实例。

    Angular provides and relies upon its own sophisticated
    [Dependency Injection](dependency-injection.html) system
    to assemble and run applications by "injecting" application parts
    into other application parts where and when needed.
    
    Angular提供并使用自己设计精密的[依赖注入](dependency-injection.html)系统来组装和运行应用程序：按时按需的将一些部件“注入”到另一些部件里面。

    At the core is an [`Injector`](#injector) that returns dependency values on request.
    The expression `injector.get(token)` returns the value associated with the given token.
    
    依赖注入的核心是一个[`注入器`](#injector)，这个注入器按需返回依赖部件。`injector.get(token)`方法返回和提供的符记参数相关的依赖部件。

    A token is an Angular type (`OpaqueToken`). We rarely deal with tokens directly; most
    methods accept a class name (`Foo`) or a string ("foo") and Angular converts it
    to a token. When we write `injector.get(Foo)`, the injector returns
    the value associated with the token for the `Foo` class, typically an instance of `Foo` itself.
    
    令牌是一个Angular的类型(`OpaqueToken`)。我们很少需要直接接触令牌。绝大多数类方法都接受类名称 (`Foo`)或者字符串("foo")，Angular把这些类名称和字符串转换为令牌。
    当我们使用`injector.get(Foo)`，注入器返回用 `Foo`类生成的的令牌对应的依赖值，这个依赖值一般是`Foo`类实例。

    Angular makes similar requests internally during many of its operations
    as when it creates a [`Component`](#AppComponent) for display.
    
    Angular新建一个[组件](#AppComponent)的过程中，会在内部有很多类似的（依赖注入）请求。

    The `Injector` maintains an internal map of tokens to dependency values.
    If the `Injector` can't find a value for a given token, it creates
    a new value using a `Provider` for that token.
    
    `注入器`维护一个令牌与其对应的依赖值对照图。如果`注入器`不能找到一个令牌对应的依赖值，它就会使用`Provider`新建一个依赖值。

    A [Provider](#provider) is a recipe for
    creating new instances of a dependency value associated with a particular token.
    
    一个`Provider`(#provider)是一个使用指定令牌来新建其对应的依赖实例的方法。

    An injector can only create a value for a given token if it has
    a `Provider` for that token in its internal provider registry.
    Registering providers is a critical preparatory step.
    
    如果在注入器的内部注册表里面，一个令牌对应的依赖值是一个`Provider`，那么注入器只能为令牌创建一个依赖值。注册Provider是一个非常关键的准备步骤。

    Angular registers some of its own providers with every injector.
    We can register our own providers. Quite often the best time to register a `Provider`
    is when we [bootstrap](#bootstrap) the application.
    There are other opportunities to register as well.
    
    Angular为每个注册器注册很多自己的Provider。我们可以注册一些自己的Provider。一般最好的注册Provider的时间是在应用程序的[引导程序Bootstrap](#bootstrap)的时候。
    我们也有其他很多机会注册Provider。

    Learn more in the [Dependency Injection](guide/dependency-injection.html) chapter.
    
    到[依赖注入](guide/dependency-injection.html)章节学习更多关于依赖注入的知识
    
:marked
  ## Directive
  ## 指令
.l-sub-section
  :marked
    An Angular class responsible for creating, re-shaping, and interacting with HTML elements
    in the browser DOM. Directives are Angular's most fundamental feature.

    指令是一个Angular类，这个类负责新建和重塑浏览器DOM里面HTML元素，同时负责与HTML元素的互动。指令是Angular的最基本的特征。

    A Directive is almost always associated with an HTML element or attribute.
    We often refer to such an element or attribute as the directive itself.
    When Angular finds a directive in an HTML template,
    it creates the matching directive class instance
    and gives that instance control over that portion of the browser DOM.
    
    指令几乎都是对HTML元素或元素的特征关联的。我们通常把这些关联的HTML元素或者元素特征当做指令本身。
    当Angular在一个HTML模板里面遇到一个指令的时候，它新建一个与该指令配套类的实例，然后把浏览器这个部分的DOM的控制交给这个类。

    Developers can invent custom HTML markup (e.g., `<my-directive>`) to
    associate with their custom directives. They add this custom markup to HTML templates
    as if they were writing native HTML. In this way, directives become extensions of
    HTML itself.
    
    开发人员可以为自制指令指定自定义的HTML标记（比如`<my-directive>`），然后，他们便可以像使用HTML自带标记一样把这些自定义的标记放到HTML模板里。
    这样，指令就变成了HTML的拓展了。

    Directives fall into one of three categories:
    
    指令包括了一下三个类别：
    
    1. [Components](#component) that combine application logic with an HTML template to
    render application [views]. Components are usually represented as HTML elements.
    They are the building blocks of an Angular application and the
    developer can expect to write a lot of them.    
    1. [组件](#component): 结合了程序逻辑和一个用来渲染试图的HTML模板[views]。组件一般由HTML元素代表。它们是用来组建Angular应用程序的基本单元，所以可以预料到开发人员会写很多很多组件。

    1. [Attribute Directives](#attribute-directive) that can listen to and modify the behavior of
    other HTML elements, attributes, properties, and components. They are usually represented
    as HTML attributes, hence the name.
    1. [特征指令](#attribute-directive)：可以监控和修改HTML元素、元素特征、属性和组件等的行为。它们一般有HTML元素特征（名）来体现。

    1. [Structural Directives](#structural-directive), a directive responsible for
    shaping or re-shaping HTML layout, typically by adding, removing, or manipulating
    elements and their children.
    1. [结构型指令](#structural-directive)：负责塑造或重塑HTML布局。一般都是通过添加、删除或者操作HTML元素和他的子级元素来实现的。
// #enddocregion d2

// #docregion e1
<a id="E"></a>
// #enddocregion e1
// #docregion e2
.l-main-section
:marked
  ## ECMAScript  
.l-sub-section
  :marked
    The [official JavaScript language specification](https://en.wikipedia.org/wiki/ECMAScript).
    
    [官方Javascript语言规范](https://en.wikipedia.org/wiki/ECMAScript)
    
    The latest approved version of JavaScript is
    [ECMAScript 2015](http://www.ecma-international.org/ecma-262/6.0/)
    (AKA "ES2015" or "ES6") and many Angular 2 developers will write their applications
    either in this version of the language or a dialect that strives to be
    compatible with it such as [TypeScript](#typesScript).
    
    最新的被认可的Javascript版本是[ECMAScript 2015](http://www.ecma-international.org/ecma-262/6.0/)，（也交“ES2015”或“ES6”）。Angular 2的开发者要么这个版本的Javascript，要么使用与这个版本兼容的语言，比如[TypeScript](#typesScript)。
   
    Most modern browsers today only support the prior "ECMAScript 5" (AKA ES5) standard.
    Applications written in ES2015 or one of its dialects must be "[transpiled](#transpile)"
    to ES5 JavaScript.
    
    目前，几乎所有现代游览器都只支持上一版本“ECMAScript 5” （也就是ES5）标准。使用ES2015或者其他兼容语言开发的应用程序，都必须被编译“[transpiled](#transpile)”成ES5 Javascript。

    Angular 2 developers may choose to write in ES5 directly.
    
    Angular 2的开发者也可以选择直接使用ES5编程。
    
:marked
  ## ECMAScript 2015  
.l-sub-section
  :marked
    The lastest released version of JavaScript,
    [ECMAScript 2015](http://www.ecma-international.org/ecma-262/6.0/)
    (AKA "ES2015" or "ES6")
    
    最新发布的Javascript版本，[ECMAScript 2015](http://www.ecma-international.org/ecma-262/6.0/)
    (即 "ES2015" 或 "ES6")
:marked
  ## ES2015
.l-sub-section
  :marked
    Short hand for "[ECMAScript 2015](#ecmascript=2015)".
    
    “[ECMAScript 2015](#ecmascript=2015)”的简写。
:marked
  ## ES6
.l-sub-section
  :marked
    Short hand for "[ECMAScript 2015](#ecmascript=2015)".
    
    [ECMAScript 2015](#ecmascript=2015)的简写。
:marked
  ## ES5
.l-sub-section
  :marked
    Short hand for "ECMAScript 5", the version of JavaScript run by most modern browsers.
    See [ECMAScript](#ecmascript).
    
    “ECMAScript 5”的简写，大部分现代浏览器使用的Javascript版本。请看[ECMAScript](#ecmascript)。
// #enddocregion e2

// #docregion f-l
<a id="F"></a>
<a id="G"></a>
<a id="H"></a>
<a id="I"></a>
.l-main-section
:marked
  ## Injector
  ## 注入器
.l-sub-section
  :marked
    An object in the Angular [dependency injection system](#dependency-injection)
    that can find a named "dependency" in its cache or create such a thing
    with a registered [provider](#provider).

    一个Angular[依赖注入系统](#dependency-injection)内部的对象，它可以在自己的内部缓存找到已点名的依赖或者利用一个注册过的[provider](#provider)新建一个依赖。
:marked
  ## Input
.l-sub-section
  :marked
    A directive property that can be the ***target*** of a
    [Property Binding](guide/template-syntax.html#property-binding).
    Data values flow *into* this property from the data source identified
    in the template expression to the right of the equal sign.
    
    一个指令属性：是[属性绑定Property Binding](guide/template-syntax.html#property-binding)的目标。数据值从处于模板表达式等号右边的数据源中，流入这个指令属性。

    See the [Template Syntax](guide/template-syntax.html#inputs-outputs) chapter.
    
    请看[模板语法Template Syntax](guide/template-syntax.html#inputs-outputs)章节。

:marked
  ## Interpolation
  ## 插值表达式
.l-sub-section
  :marked
    A form of [Property Data Binding](#data-binding) in which a
    [template expression](#template-expression) between double-curly braces
    renders as text.  That text may be concatenated with neighboring text
    before it is assigned to an element property
    or displayed between element tags as in this example.
    
    一种[属性数据绑定Property Data Binding](#data-binding) 的方式：在双大括号中间的[模板表达式](#template-expression)被渲染成文本。在被指派给元素属性或者在元素标记中间显示之前，这些文本可能与傍边的文本先合并，请看下面的例子。

  code-example(language="html" escape="html").
    <label>My current hero is {{hero.name}}</label>

  :marked
    Learn more about interpolation in the
    [Template Syntax](guide/template-syntax.html#interpolation) chapter.
    
    从[模板语法Template Syntax](guide/template-syntax.html#interpolation)章节学习更多关于插值表达式的知识。

<a id="J"></a>

.l-main-section
<a id="K"></a>
:marked
  ## kebab-case
  ## 烤串命名法
.l-sub-section
  :marked
    The practice of writing compound words or phrases such that each word is separated by a dash or hyphen (-). 
     
    使用中线来分割每个单词的编写复合词或短语的命名方法。
    
    Directive selectors and the root of filenames are often spelled in kebab-case. Examples include: `my-app` and the `hero-list.component.ts`.
    
    指令选择器和文件名字等一般都用烤串命名法Kebab-case。比如`my-app`和`hero-list.component.ts`。
    
    This form is also known as [dash-case](#dash-case).
    
    这种命名法也被叫做[中线命名法dash-case](#dash-case)

<a id="L"></a>
.l-main-section
:marked
  ## Lifecycle Hooks
  ## 生命周期钩子
.l-sub-section
  :marked
    [Directives](#directive) and [Components](#component) have a lifecycle
    managed by Angular as it creates, updates and destroys them.
    
    [指令Directives](#directive)和[组件Components](#component)有生命周期，由Angular在新建、更新和销毁他们的过程中管理。

    Developers can tap into key moments in that lifecycle by implementing
    one or more of the "Lifecycle Hook" interfaces.
    
    开发者可以通过实现一个或多个“生命周期钩子”接口，切入到这个生命周期的关键时间点中。

    Each interface has a single hook method whose name is the interface name prefixed with `ng`.
    For example, the `OnInit` interface has a hook method names `ngOnInit`.
    
    每个接口有一个唯一的钩子类方法方法，它的名字一般是接口的名字加前缀 `ng`。比如，`OnInit`接口的钩子类方法方法名字为 `ngOnInit`。

    Angular calls these hook methods in the following order:
    
    Angular会按照下面的顺序调用钩子类方法：
    
    * `ngOnChanges` - called when an [input](#input)/[output](#output) binding values change
    * `ngOnInit` - after the first `ngOnChanges`
    * `ngDoCheck` - developer's custom change detection
    * `ngAfterContentInit` - after component content initialized
    * `ngAfterContentChecked` - after every check of component content
    * `ngAfterViewInit` - after component's view(s) are initialized
    * `ngAfterViewChecked` - after every check of a component's view(s)
    * `ngOnDestroy` - just before the directive is destroyed.
    
    * `ngOnChanges` - 在[输入input](#input)/[输出output](#output)绑定的值变化的时候调用。
    * `ngOnInit` - 在第一个`ngOnChanges`后调用。
    * `ngDoCheck` - 开发者自定义变化监测器。
    * `ngAfterContentInit` - 在组件初始化以后调用。
    * `ngAfterContentChecked` - 在检查每个组件内容后调用。
    * `ngAfterViewInit` - 在组件试图初始化后调用。
    * `ngAfterViewChecked` - 在检查每个组件试图后调用
    * `ngOnDestroy` - 在指令销毁前调用。

    Learn more in the [Lifecycle Hooks](guide/lifecycle-hooks.html) chapter.
    
    请看[生命周期钩子Lifecycle Hooks](guide/lifecycle-hooks.html)章节。 
// #enddocregion f-l

// #docregion m1
<a id="M"></a>
// #enddocregion m1
// #docregion m2
.l-main-section
:marked
  ## Module
  ## 模块
.l-sub-section
  :marked
    Angular apps are modular.
    
    Angular应用程序是模块化的。
    
    In general, we assemble our application from many modules, both the ones we write ourselves
    and the ones we acquire from others.
    
    一般来说，我们用模块来组装我们的应用程序，这些模块包含我们自己编写的模块和从其他地方获取的模块。

    A typical module is a cohesive block of code dedicated to a single purpose.
    
    一个典型的模块，是单一用途的代码块的凝聚。

    A module **exports** something of value in that code, typically one thing such as a class.
    A module that needs that thing, **imports** it.
    
    模块一般**输出**一个东西：类。
    模块如果需要什么东西，那就**导入**它。

    The structure of Angular modules and the import/export syntax
    is based on the [ES2015](#es2015) module standard
    described [here](http://www.2ality.com/2014/09/es6-modules-final.html).
    
    Angular的模块结构和输出/导入语法是基于[ES2015](#es2015)模块标准上的，请看[这里](http://www.2ality.com/2014/09/es6-modules-final.html).

    An application that adheres to this standard requires a module loader to
    load modules on request and resolve inter-module dependencies.
    Angular does not ship with a module loader and does not have a preference
    for any particular 3rd party library (although most samples use SystemJS).
    Application developers may pick any module library that conforms to the standard
    
    采取这个标准的应用程序需要一个模块装载器来按需装载模块并解析模块的依赖关系。Angular不包含任何模块装载器，也不推荐任何第三方库(虽然几乎所有例子都使用SystemJs)。
    应用程序开发者可以自己选择任何与这个标准兼容的模块装置库。

    Modules are typically named after the file in which the exported thing is defined.
    The Angular [DatePipe](https://github.com/angular/angular/blob/master/modules/angular2/src/common/pipes/date_pipe.ts)
    class belongs to a feature module named `date_pipe` in the file `date_pipe.ts`.

    模块一般与他输出的东西的所在文件同名。比如, Angular的[日期管道DatePipe](https://github.com/angular/angular/blob/master/modules/angular2/src/common/pipes/date_pipe.ts)类属于名叫`date_pipe`的特性模块，在文件`date_pipe.ts`里。
    
    Developers rarely access Angular feature modules directly.
    We usually import them from public-facing **library modules**
    called [**barrels**](#barrel). Barrels are groups of logically related modules.
    The `angular2/core` barrel is a good example.
    
    开发者很少需要直接访问Angular的特性模块。我们通常从名为[**封装桶**](#barrel)的公共**模块库**里面导入他们。封装通是有逻辑关联的模块的集合。封装通`angular2/core`是一个很好的例子。

    Learn more in "[Modules, barrels and bundles](https://github.com/angular/angular/blob/master/modules/angular2/docs/bundles/overview.md)".
    
    更多信息请看"[模块、封装桶和捆绑包](https://github.com/angular/angular/blob/master/modules/angular2/docs/bundles/overview.md)".
    
// #enddocregion m2

// #docregion n-s
- var lang = current.path[1]
- var decorator = lang === 'dart' ? 'annotation' : '<a href="#decorator">decorator</a>'
- var atSym = lang === 'js' ? '' : '@'
<a id="N"></a>
<a id="O"></a>
.l-main-section
:marked
  ## Output
  ## 输出
.l-sub-section
  :marked
    A directive property that can be the ***target*** of an
    [Event Binding](guide/template-syntax.html#property-binding).
    Events stream *out* of this property to the receiver identified
    in the template expression to the right of the equal sign.
    
    输出（Output）是一个指令属性，它可以一个[事件绑定Event Binding](guide/template-syntax.html#property-binding)的**标靶**。
    事件流可以通过指令属性，流到接收者（模板表达式等号的右边就是接收者）
    
    See the [Template Syntax](guide/template-syntax.html#inputs-outputs) chapter.
    
    请看[模板语法Template Syntax](guide/template-syntax.html#inputs-outputs)章节。

.l-main-section
<a id="P"></a>
:marked
  ## PascalCase
  ## 帕斯卡命名法
.l-sub-section
  :marked
    The practice of writing compound words or phrases such that each word or abbreviation begins with a capital letter. 
    Class names are typically spelled in PascalCase. Examples include: `Person` and `Customer`.
    
    按照每一个单词都是以大写开头的规则的编写复合词或短语的命名方法叫做帕斯卡命名法。类的名字一般都采用帕斯卡命名法。比如`Person`和`Customer`
    
    This form is also known as **upper camel case**, to distinguish it from **lower camel case** which we simply call [camelCase](#camelcase).
    In this documentation, "PascalCase" means *upper camel case* and  "camelCase" means *lower camel case*.
    
    这种命名法也被叫做**大驼峰式命名法**，便于与**小驼峰式命名法”或[驼峰式命名法camelCase](#camelCase)。
    在本教程中，“帕斯卡命名法”都是指的*大驼峰式命名法”，“驼峰式命名法”指的都是“小驼峰式命名法”

:marked
  ## Pipe
  ## 管道
.l-sub-section
  :marked
    An Angular pipe is a function that transforms input values to output values for
    display in a [view](#view). We use the `#{atSym}Pipe` !{decorator}
    to associate the pipe function with a name. We then can use that
    name in our HTML to declaratively transform values on screen.
    
    Angular的管道是一个函数，用来把输入值转变为输出值给视图 [view](#view)。我们使用 `#{atSym}Pipe` !{decorator}来把管道函数链接到它的名字上。
    然后，我们可以在HTML中使用它的名字来，用声明的形式，在显示时把输入值转变输出值。
    
    Here's an example that uses the built-in `currency` pipe to display
    a numeric value in the local currency.
    
    下面是一个使用内建`货币`管道来把数字值显示为本地货币的例子。

  code-example(language="html" escape="html").
    <label>Price: </label>{{product.price | currency}}
  :marked
    Learn more in the chapter on [pipes](guide/pipes.html) .
    
    到[管道pipes](guide/pipes.html)章节获取更多。

:marked
  ## Provider
  ## Provider
.l-sub-section
  :marked
    A Provider creates a new instance of a dependency for the Dependency Injection system.
    It relates a lookup token to code - sometimes called a "recipe" - that can create a dependency value.
    
    Provider为依赖注入系统新建一个依赖的实例。它是关于通过令牌查询代码，有时被叫做“方剂”，可以创建依赖值。
    
    For example, `new Provider(Foo, {useClass: Foo})` creates a `Provider`
    that relates the `Foo` token to a function that creates a new instance of the `Foo` class.
    
    比如，`new Provider(Foo, {useClass: Foo})`新建一个`Provider`，把`Foo`令牌联系到一个函数，这个函数新建一个`Foo`类的实例。

    There are other ways to create tokens and recipes.
    See [Dependency Injection](#dependency-injection) chapter to learn more.
    
    还有其他一些方法建立令牌和方剂。
    请看[依赖注入Dependency Injection](#dependency-injection)以获取更多信息。 

.l-main-section
<a id="Q"></a>
<a id="R"></a>
:marked
  ## Router
  ## 路由器
.l-sub-section
  :marked
    Most applications consist of many screens or [views](#view).
    The user navigates among them by clicking links and buttons
    and taking other similar actions that cause the application to
    replace one view with another.
    
    大部分应用程序包含多个屏或视图[views](#view)。用户通过点击链接、按钮和其他类似动作，在他们之间穿梭，这样应用程序从一个视图变换到另一个视图。

    The Angular [Component Router](guide/router.html) is a richly featured mechanism for configuring
    and managing the entire view navigation process including the creation and destruction
    of views.
    
    Angular的[组件路由器Component Router](guide/router.html)是一个设置和管理整个视图导航过程的特征非常丰富的机制，包括建立和销毁视图。
    
:marked
  ## Routing Component
  ## 路由组件
.l-sub-section
  :marked
    A [Component](#component) with an attached router.

    路由组件是一个附加了路由的[组件Component](#component)。

    In most cases, the component became attached to a [router](#router) by means
    of a `#{atSym}RouterConfig` #{decorator} that defined routes to views controlled by this component.
    
    在大部分情况下，通过`#{atSym}RouterConfig` #{decorator}装饰器，这个组件通常会被附加一个[router路由器](#router)，来定义被这个组件控制的多个视图的路径。

    The component's template has a `RouterOutlet` element where it can display views produced by the router.
    
    组件的模板有一个`路由出口RouterOutlet`元素，用来显示被路由器提供的视图。

    It likely has anchor tags or buttons with `RouterLink` directives that users can click to navigate.
    
    它很大可能还会有一些有`RouterLink`指令的锚标记或按钮，用户可以用来点击导航。

<a id="S"></a>
.l-main-section
:marked
  ## Structural Directive
  ## 结构型指令
.l-sub-section
  :marked
    A category of [Directive](#directive) that can
    shape or re-shape HTML layout, typically by adding, removing, or manipulating
    elements and their children.

    一类可以通过添加、删除或操作元素和其子级，来塑造或重塑HTML布局的指令，
    
    The `ngIf` "conditional element" directive and the `ngFor` "repeater" directive are
    good examples in this category.
    
    `ngIf`"有条件的元素conditional element"指令和 `ngFor` "循环器repeater"指令是很好的结构型指令。
    
// #enddocregion n-s

// #docregion t1
<a id="T"></a>
.l-main-section
:marked
  ## Template
  ## 模板
.l-sub-section
  :marked
    A template is a chunk of HTML that Angular uses to render a [view](#view) with
    the support and continuing guidance of an Angular [Directive](#directive),
    most notably a [Component](#component).

    模板是一块HTML。在Angular指令（最典型的 指令[组件Component](#component)）的支持和范围下，Angular用它来渲染试图。
    
    We write templates in a special [Template Syntax](guide/template-syntax.html).
    
    我们使用特殊的[模板语法Template Syntax](guide/template-syntax.html)来编写模板。

:marked
  ## Template Expression
  ## 模板表达式
.l-sub-section
  :marked
    An expression in a JavaScript-like syntax that Angular evaluates within
    a [data binding](#data-binding).  Learn how to write template expressions
    in the [Template Syntax](guide/template-syntax.html#template-expressions) chapter.

    Angular在[数据绑定data binding](#data-binding)内评估的类似Javascript语法的表达式。在[模板语法Template Syntax](guide/template-syntax.html#template-expressions)章节了解更多模板表达式的知识。
// #enddocregion t1
// #docregion t2
:marked
  ## Transpile
  ## 编译
.l-sub-section
  :marked
    The process of transforming code written in one form of JavaScript
    (e.g., TypeScript) into another form of JavaScript  (e.g., [ES5](#es5)).

    把用Javascript形式语言（比如TypeScript）编写的程序转换到另一个形式的JavaScript（例如[ES5](#es5))。
 :marked
  ## TypeScript
.l-sub-section
  :marked
    A version of JavaScript that supports most [ECMAScript 2015](#ecmascript=2015)
    language features and many features that may arrive in future versions
    of JavaScript such as [Decorators](#decorator).
    
    一个支持几乎所有[ECMAScript 2015](#ecmascript=2015)语言特性和一些将来版本可能有的特性（比如装饰器[Decorators](#decorator)）的JavaScript语言。

    TypeScript is also noteable for its optional typing system which gives
    us compile-time type-checking and strong tooling support (e.g. "intellisense",
    code completion, refactoring, and intelligent search). Many code editors
    and IDEs support TypeScript either natively or with plugins.
    
    TypeScript同时也以其可选的类型系统出名。该类型系统给我们提供编译时间类型检查和强大的工具支持（比如“Intellisense”， 自动代码补齐，重构和智能搜索等）。许多程序编辑器和开发环境自带TypeScript支持或者通过插件支持。

    TypeScript is the preferred language for Angular 2 development although
    we are welcome to write in other JavaScript dialects such as [ES5](#es5).
    
    TypeScript是Angular 2推荐使用的语言，当然，我们也欢迎使用其他JavaScript语言，比如[ES5](#es5)。

    Angular 2 itself is written in TypeScript.
    
    Angular 2自身是用TypeScript编写的。

    Learn more about TypeScript on its [website](http://www.typescriptlang.org/).
    
    在TypeScript[官方网站](http://www.typescriptlang.org/)了解更多情况。
    
// #enddocregion t2

// #docregion u-z
<a id="U"></a>
<a id="V"></a>
.l-main-section
:marked
  ## View
  ## 视图
.l-sub-section
  :marked
    A view is a portion of the screen that displays information and responds
    to user actions such as clicks, mouse moves, and keystrokes.

    视图是屏幕的一块用于显示信息并回应用户动作，比如点击、移动鼠标和按键等。

    Angular renders a view under the control of one or more [Directives](#directive),
    especially  [Component](#component) directives and their companion [Templates](#template).
    The Component plays such a prominent role that we often
    find it convenient to refer to a component as a view.
    
    Angular在一个或多个[指令](#directive)的控制下渲染视图，尤其是[组件](#component)指令和它配带的[模板](#template)。
    组件扮演非常突出的角色，我们甚至经常为了方便，把组件代替视图来提及。

    Views often contain other views and any view might be loaded and unloaded
    dynamically as the user navigates through the application, typically
    under the control of a [router](#router).
    
    视图一般包含其他视图，任何视图在用户在应用程序中导航的时候，可能被动态加载或卸载，一般[路由器](#router)的控制下进行。

.l-main-section
<a id="W"></a>
<a id="X"></a>
<a id="Y"></a>
<a id="Z"></a>
:marked
  ## Zones
  ## 区域
.l-sub-section
  :marked
    Zones are a mechanism for encapsulating and intercepting
    a JavaScript application's asynchronous activity.
    
    区域是一个封装和截听JavaScript应用程序异步动作的机制。

    The browser DOM and JavaScript have a limited number
    of asynchronous activities, activities such as DOM events (e.g., clicks),
    [promises](#promise), and
    [XHR](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)
    calls to remote servers.
    
    浏览器DOM和JavaScript之间有一些有限数量的异步活动，比如Dom事件（比如点击）、[契约promises](#promise)、和[XHR](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)查询远程服务等。

    Zones intercept all of these activities and give a "zone client" the opportunity
    to take action before and after the async activity completes.
    
    区域能截听所有这些活动，并给“区域客户端”机会在异步活动完成之前和之后采取行动。

    Angular runs our application in a zone where it can respond to
    asynchronous events by checking for data changes and updating
    the information it displays via [data binding](#data-binding).
    
    Angular在一个区域内运行我们的应用程序，在这个区域内，它可以对异步事件做出反应，通过检查数据变化、利用数据绑定[data binding](#data-binding)更新信息显示。

    Learn more about zones in this
    [Brian Ford video](https://www.youtube.com/watch?v=3IqtmUscE_U).
    
    在这里学习 [Brian Ford video](https://www.youtube.com/watch?v=3IqtmUscE_U)更多关于区域的知识。
// #enddocregion u-z
