include ../_util-fns

:marked
  Angular 2 is a framework to help us build client applications in HTML and JavaScript.
  
  Angular 2是一个使用HTML和JavaScript构建客户端应用的框架。
  
  The framework consists of several cooperating libraries, some of them core and some optional.
  
  这个框架包括一系列紧密合作的库，有些是核心库，有些是可选库。
  
  We write applications by composing HTML *templates* with Angularized-markup, 
  writing *component* classes to manage those templates, adding application logic in *services*,
  and handing the top root component to Angular's *bootstrapper*. 
  
  我们用带有Angular标记的HTML写 *模板* ，用 *组件* 类来管理这些模板，用 *服务* 添加应用逻辑，用根组件来完成Angular *启动* 。
  把这些组合起来，我们就得到了一个应用程序。
  
  Angular takes over, presenting our application content in a browser and responding to user interactions
  according to the instructions we provided.
  
  Angular在浏览器中接管、展现我们的应用内容，并且根据我们提供的指令响应用户的交互。
  
<!-- figure img(src="/resources/images/devguide/architecture/airplane.png" alt="Us" align="left" style="width:200px; margin-left:-40px;margin-right:10px" ) -->
:marked
  Of course there is more to it than this. We'll learn the details when we dive into the guide chapters.
  Let's get the big picture first.

  当然，这只是冰山一角。随着内容的深入，我们还会学到更多的细节。
  我们先来看看宏观图景。

figure
  img(src="/resources/images/devguide/architecture/overview2.png" alt="overview" style="margin-left:-40px;" width="700")
:marked
  The architecture diagram identifies the eight main building blocks of an Angular 2 application:
  
  这个架构图展现了Angular应用中的8个主要构造块：
  1. [Module](#module)   
  1. [模块(Module)](#module)
  1. [Component](#component)
  1. [组件(Component)](#component)
  1. [Template](#template)
  1. [模板(Template)](#template)
  1. [Metadata](#metadata)
  1. [元数据(Metadata)](#metadata)
  1. [Data Binding](#data-binding)
  1. [数据绑定(Data Binding)](#data-binding)
  1. [Directive](#directive)
  1. [指令(Directive)](#directive)
  1. [Service](#service)
  1. [服务(Service)](#service)
  1. [Dependency Injection](#dependency-injection)
  1. [依赖注入(Dependency Injection)](#dependency-injection)

  Learn these eight and we're on our way.
  
  我们这一路上就将学习这8点。

.l-sub-section
  :marked
      The code referenced in this chapter is available as a [live example](/resources/live-examples/architecture/ts/plnkr.html).
      
      本章所引用的代码可以在这个[鲜活范例](/resources/live-examples/architecture/ts/plnkr.html)中找到。
<a id="module"></a>
.l-main-section
:marked
  ## The Module
  ## 模块
figure
  img(src="/resources/images/devguide/architecture/module.png" alt="模块" align="left" style="width:240px; margin-left:-40px;margin-right:10px" )
:marked
  Angular apps are modular. 
  
  Angular应用是模块化的。
  
  In general we assemble our application from many **modules**.
  
  我们的程序通常都是由很多 *模块* 组装成的。
  
  A typical module is a cohesive block of code dedicated to a single purpose.
  A module **exports** something of value in that code, typically one thing such as a class.
  
  典型的组件是一个内聚的代码块组成的，用以完成单一的目的。
  <br clear="all"><br>
.l-sub-section
  :marked
     ### Modules are optional
     ### 组件是可选的
     We highly recommend modular design. TypeScript has great support for ES2015 module syntax and our chapters assume we're taking a modular
     approach using that syntax. That's why we list *Module* among the basic building blocks.
     
     我们强烈推荐遵循模块化设计。TypeScript对ES2015的模块语法支持很好，本章假定我们使用那些语法作为模块化方案。这就是为什么我们要把 *模块* 列为一种基本构造块。
     
     Angular itself doesn't require a modular approach nor this particular syntax. Don't use it if you don't want it.
     Each chapter has plenty to offer after you steer clear of the `import` and `export` statements.
     
     Angular本身并不需要模块化方案或使用这种特定的语法。如果你不喜欢，可以不用它。
     在你弄清楚了`import`和`export`语句之后，它在每章都会出现很多。
     
     Find setup and organization clues in the JavaScript track (select it from the combo-box at the top of this page) 
     which demonstrates Angular 2 development with plain old JavaScript and no module system. 
     
     在JavaScript（可以从页面顶部的组合框选择它）分支下，可以找到如何安装和进行文件组织的线索。
     它示范了如何用老版本的JavaScript语言，在没有模块化系统的情况下进行Angular 2开发。
:marked
  Perhaps the first module we meet is a module that exports a *component* class. 
  The component is one of the basic Angular blocks, we write a lot of them,
  and we'll talk about components in the next segment. For the moment it is enough to know that a
  component class is the kind of thing we'd export from a module.
  
  也许我们遇到的第一个模块，就是用于导出 *组件* 类的那个。
  组件是Angular最基本的构造块之一，我们会写很多。下一段，我们将会讨论组件。
  但目前，只要知道组件类需要我们从模块中导出就行了。
  
  Most applications have an `AppComponent`. By convention, we'll find it in a file named `app.component.ts`. 
  Look inside such a file and we'll see an `export` statement like this one.
  
  大多数应用都有一个`AppComponent`。作为一项惯例，它会位于一个名叫`app.component.ts`的文件中。
  打开它，我们将会看到一个`export`语句，就像这样：
+makeExample('architecture/ts/app/app.component.ts', 'export', 'app/app.component.ts (节选)')(format=".")
:marked
  The `export` statement tells TypeScript that this is a module whose
  `AppComponent` class is public and accessible to other modules of the application.
  
  `export`语句告诉TypeScript：这是一个模块，`AppComponent`类是公开的，可以被应用中的其它模块访问。
  
  When we need a reference to the `AppComponent`, we **import** it like this:
  
  当我们需要引用`AppComponent`时，我们 **导入** 它，就像这样：
+makeExample('architecture/ts/app/main.ts', 'import', 'app/main.ts (节选)')(format=".")
:marked
  The `import` statement tells the system it can get an `AppComponent` from a module named `app.component`
  located in a neighboring file. 
  The **module name** (AKA module id) is often the same as the filename without its extension.
  
  `import`语句告诉系统，它能从附近一个叫作`app.component`的文件中获得一个`AppComponent`组件。
  **模块名** （又叫模块ID）通常和去掉扩展名后的文件名相同。
  ### Library Modules 
  ### 库模块
figure
  img(src="/resources/images/devguide/architecture/library-module.png" alt="组件" align="left" style="width:240px; margin-left:-40px;margin-right:10px" )
:marked
  Some modules are libraries of other modules.
  
  有些模块是其它模块的库。
  
  Angular itself ships as a collection of library modules within several npm packages.
  Their names begin with the `@angular` prefix. 
  Each Angular library contains a [barrel](../glossary.html#barrel) module
  that is actually a public façade over several logically-related private modules.

  Angular本身就是用一组库模块的形式发布的，它们都以`@angular`为前缀。
  每个Angular库都包含一个[封装桶](../glossary.html#barrel)模块。
  它实际上是一个公开的外观层（façade），囊括了许多逻辑上相关的私有模块。
  
  The `@angular/core` library is the primary Angular library module from which we get most of what we need.
  
  `angular2/core`库是主要的Angular库模块，从这里我们能获得所需的大部分东西。
  <br clear="all">
  
  There are other important Angular library modules too such as `@angular/common`, `@angular/router`, and `@angular/http`.
  
  还有另外一些重要的Angular库模块，比如`@angular/common`、`@angular/router` 和 `@angular/http`。

  We import what we need from an Angular library module in much the same way.
  For example, we import the Angular **`Component` *function*** from the *@angular/core* module like this:
  
  我们从Angular库模块中导入所需内容的方式都与此类似。
  比如，我们从 *@angular2/core* 中导入Angular **`Component` *函数* ** 的代码是这样的：
+makeExample('architecture/ts/app/app.component.ts', 'import')(format=".")
:marked
  Compare that syntax to our previous import of `AppComponent`.
  
  比较一下它和前面导入`AppComponent`时的语法。
+makeExample('architecture/ts/app/main.ts', 'import')(format=".")
:marked
  Notice the difference? 
  In the first case, when importing from an Angular library module,
  the import statement refers to the bare module name, `@angular/core`, *without a path prefix*.
  
  注意到不同之处了吗？
  前面的方式中，当从Angular库模块中导入时，import语句引用的是一个裸模块名 —— `angular2/core` —— *没有路径前缀* 。
  
  When we import from one of *our* own files, we prefix the module name with the file path.
  In this example we specify  a relative file path (./). That means the
  source module is in the same folder (./) as the module importing it.
  We could path up and around the application folder structure if the source module were somewhere else.
  
  当我们从 *自己的* 文件中导入时，模块名中带有前缀，在这个例子中，是一个相对路径（./）。这表示源模块位于与导入它的模块相同的目录中（./）。
  如果源模块位于其它位置的话，我们还可以向上引用应用目录结构中的任意路径（../../../somewhere/）。
.l-sub-section
  :marked
    We import and export in the ECMAScript 2015 (ES2015) module syntax. 
    Learn more about that syntax [here](http://www.2ality.com/2014/09/es6-modules-final.html)
    and many other places on the web.
    
    我们导入和导出使用的是ECMAScript 2015 (ES2015)的语法。
    要学习更多关于此语法的知识，参见[这里](http://www.2ality.com/2014/09/es6-modules-final.html)，也可以在网上的很多地方找到。
    
    The infrastructure *behind* module loading and importing is an important subject.
    But it's a subject outside the scope of this introduction to Angular. 
    While we're focused on our application, *import* and *export*
    is about all we need to know.
    
    关于模块加载和导入背后的基础设施，是一个很重要的话题。
    但是，这个话题在介绍Angular的范围之外。在我们聚焦于讲解应用的时候，知道 *import* 和 *export* 就足够了。
:marked
  The key take-aways are:
  
  要知道的关键是：
  * Angular apps are composed of modules.
  * Angular应用是由模块组成的。
  * Modules export things &mdash; classes, function, values &mdash; that other modules import.
  * 模块导出一些东西 —— 类，函数，值，供其它模块导入。
  * We prefer to write our application as a collection of modules, each module exporting one thing.
  * 我们喜欢把应用写成一组模块，每个模块只导出一个东西。
  
  The first module we write will most likely export a component.
  
  我们写的第一个模块很可能是导出一个组件。
.l-main-section
<a id="component"></a>
:marked
  ## The Component
  ## 组件
figure
  img(src="/resources/images/devguide/architecture/hero-component.png" alt="组件" align="left" style="width:200px; margin-left:-40px;margin-right:10px" )
:marked
  A **Component** controls a patch of screen real estate that we could call a *view*. 
  The shell at the application root with navigation links, that list of heroes, the hero editor ... 
  they're all views controlled by Components.
  
  **组件** 控制屏幕中的补丁大的一小块儿地方，我们称之为 *视图* 。
  应用的“外壳”包括一些导航链接、一个英雄列表、英雄编辑器…… 它们都是被组件控制的视图。
  
  We define a Component's application logic - what it does to support the view - inside a class.
  The class interacts with the view through an API of properties and methods. 
  
  我们定义了一个组件的应用逻辑 —— 它被用来为视图提供支持 —— 放在类中。
  组件用一些由属性和方法组成的API与视图交互。
  
  <a id="component-code"></a>
  A `HeroListComponent`, for example, might have a `heroes` property that returns an array of heroes
  that it acquired from a service.
  It might have a `selectHero()` method that sets a `selectedHero` property when the user clicks on a hero from that list.
  It might be a class like this:
  
  <a id="component-code"></a>
  比如，`HeroListComponent`组件，可能有一个`heroes`属性，它返回一个英雄的数组，这个数据是从服务中取得的。
  它还可能有一个`selectHero()`方法，用来在用户从列表中点击一个英雄时设置`selectedHero`属性。
  它可能是像这样的一个类：

+makeExample('architecture/ts/app/hero-list.component.ts', 'class', 'app/hero-list.component.ts')
:marked
  Angular creates, updates, and destroys components as the user moves through the application.
  The developer can take action at each moment in this lifecycle through optional [Lifecycle Hooks](lifecycle-hooks.html).
  
  当用户在这个应用中“移动”时，Angular会创建、更新、销毁组件。
  开发人员还可以通过[生命周期钩子](lifecycle-hooks.html)在组件生命周期的每个时间点做出自己的处理。
.l-sub-section
  :marked
    We're not showing those hooks in this example 
    but we are making a mental note to find out about them later.
    
    我们不会在这个例子中展示这些钩子，先在脑子中留个记号，将来再翻出来讲。
    
    We may wonder who is calling that constructor? Who provides the service parameter?
    For the moment, have faith that Angular will call the constructor and deliver an
    appropriate `HeroService` when we need it.

    我们可能会好奇，谁调用那个构造函数？谁为服务提供参数？
    现在，只要相信Angular就行了，它会去调用构造函数，并且在我们需要的时候交给我们一个合适的`HeroService`实例。
 
.l-main-section
<a id="template"></a>
:marked
  ## The Template
  ## 模板
figure
  img(src="/resources/images/devguide/architecture/template.png" alt="模板" align="left" style="width:200px; margin-left:-40px;margin-right:10px" )
:marked
  We define a Component's view with its companion **template**. A template is a form of HTML
  that tells Angular how to render the Component.
  
  我们通过伴随它的 **模板** 来定义组件的视图。模板是HTML的一种形式，用来告诉Angular如何渲染组件。

  A template looks like regular HTML much of the time ... and then it gets a bit strange. Here is a
  template for our `HeroList` component.
  
  基本上，模板看起来很像标准HTML……当然也略有一些奇怪的地方。下面是我们`HeroList`组件的一个模板。
+makeExample('architecture/ts/app/hero-list.component.html',null,'app/hero-list.component.html')
:marked
  We recognize `<h2>` and  `<div>`. 
  But there's other markup that no one told us about in school.
  What are `*ngFor`, `{{hero.name}}`, `(click)`, `[hero]`, and `<hero-detail>`?
  
  我们认得`<h2>`和`<div>`。
  但有一些其他的标签/属性是我们在学校中从没有听说过的。
  什么是`*ngFor`、`{{hero.name}}`、`(click)`、`[hero]`和`<hero-detail>`？
  
  These are examples of Angular's [template syntax](template-syntax.html). 
  We will grow accustomed to that syntax and may even learn to love it.
  We'll begin to explain it in a moment.
  
  这些是Angular [模板语法](template-syntax.html) 的例子。
  我们会逐步习惯这些语法，甚至会学着爱上它。
  一会儿我们再解释它。
  
  Before we do, focus attention on the last line. 
  The `<hero-detail>` tag is a custom element representing the `HeroDetailComponent`.
  
  在我们开始前，注意最后那行。
  `<hero-detail>`是一个自定义元素的标签，用来表示`HeroDetailComponent`组件。
  
  The `HeroDetailComponent` is a *different* component than the `HeroListComponent` we've been reviewing.
  The `HeroDetailComponent` (code not shown) presents facts about a particular hero, the
  hero that the user selects from the list presented by the `HeroListComponent`.
  The `HeroDetailComponent` is a **child** of the `HeroListComponent`.
  
  `HeroDetailComponent`是和我们审视过的`HeroListComponent` *不同* 的组件。
  `HeroDetailComponent`（未展示代码）展现一个特定英雄的情况，这个英雄是用户从`HeroListComponent`所展示的列表中选择的。
  `HeroDetailComponent`是`HeroListComponent`的 *子组件* 。

figure
  img(src="/resources/images/devguide/architecture/component-tree.png" alt="组件树" align="left" style="width:300px; margin-left:-40px;margin-right:10px" )
:marked
  Notice how `<hero-detail>` rests comfortably among the HTML elements we already know. 
  We can mix ... and will mix ... our custom components with native HTML in the same layouts.
  
  注意：`<hero-detail>`是多么和谐的出现在我们已经知道的那些HTML元素中。
  我们在同一个布局中，可以混合……而且还将混合……我们的自定义组件与原生HTML。
  
  And in this manner we can and will compose complex component trees to build out our richly featured application.
  
  在这种方式下，我们能而且将会组合出复杂的组件树，来构建我们那些丰富多彩的应用。
<br clear="all">

.l-main-section
<a id="metadata"></a>
:marked
  ## Angular Metadata
  ## Angular元数据
figure
  img(src="/resources/images/devguide/architecture/metadata.png" alt="元数据" align="left" style="width:150px; margin-left:-40px;margin-right:10px" )
:marked
<p style="padding-top:10px">Metadata tells Angular how to process a class.</p>
<p style="padding-top:10px">元数据告诉Angular如何处理一个类。</p>
<br clear="all">
:marked
  [Looking back](#component-code) at the `HeroListComponent`, we see that it's just a class.
  There is no evidence of a framework, no "Angular" in it at all.
  
  [回头看看](#component-code)`HeroListComponent`，我们就明白，它只是一个类。
  毫无框架的迹象，里面完全没有出现"Angular"。
  
  In fact, it really is *just a class*. It's not a component until we *tell Angular about it*.
  
  实际上，它真的只是一个类。直到我们 *告诉Angular这一点* ，否则就没有组件。
  
  We tell Angular that `HeroListComponent` is a component by attaching **metadata** to the class.
  
  通过把 **元数据** 附加到类，我们告诉Angular：`HeroListComponent`是个组件。
  
  The easy way to attach metadata in TypeScript is with a **decorator**. 
  Here's some metadata for `HeroListComponent`:
  
  TypeScript中，附加元数据的简单方式是 **装饰器(decorator)** 。
  下面就是`HeroListComponent`的一些元数据。
+makeExample('architecture/ts/app/hero-list.component.ts', 'metadata', 'app/hero-list.component.ts (元数据)')
:marked
  Here we see the `@Component` decorator which (no surprise) identifies the class
  immediately below it as a Component class.
  
  这里我们看到`@Component`装饰器（理所当然的）标记出紧跟着它的这个类是一个组件类。
  
  A decorator is a function. Decorators often have a configuration parameter. 
  The `@Component` decorator takes a required configuration object with the
  information Angular needs to create and present the component and its view.
  
  装饰器是一个函数。装饰器通常还有配置参数。
  `@Component`装饰器可以带一个配置对象，这些信息会被Angular用来创建和展示组件及其视图。
  
  Here we see a few of the possible `@Component` configuration options:
  
  这里，我们看到`@Component`中的一些配置项：
  
  * `selector` - a css selector that tells Angular to create and insert an instance of this component 
  where it finds a `<hero-list>` tag in *parent* HTML. 
  If the template of the application shell (a Component) contained
  
  * `selector` - 一个css选择器，用来告诉Angular在 *父* HTML中，去寻找一个`<hero-list>`标签，然后创建组件，并插在此标签中。
  比如，如果应用“壳”组件的模板包含：
<div style="margin-left:30px">
code-example(language="html").
    &lt;hero-list>&lt;/hero-list>
</div>  
:marked
  >Angular inserts an instance of the `HeroListComponent` view between those tags.
  >Angular就会在这些标签中插入一个`HeroListComponent`视图的一个实例。
  
  * `templateUrl` - the address of this component's template which we showed [above](#template).
  * `templateUrl` - 组件模板的地址，我们在[前面](#template)看到过。
  * `directives` - an array of the Components or Directives that *this* template requires.
  We saw in the last line of our template that we expect Angular to insert a `HeroDetailComponent`
  in the space indicated by `<hero-detail>` tags. 
  Angular will do so only if we mention the `HeroDetailComponent` in this `directives` array.
  * `directives` - 一个数组，包含 *此* 模板需要的组件或指令。
  看看模板的最后一行，这表示我们希望Angular把`HeroDetailComponent`的实例放在`<hero-detail>`标签中。
  但，只有当我们在`directives`数组中引用了`HeroDetailComponent`的时候，Angular才会这么做。
  * `providers` - an array of **dependency injection providers** for services that the component requires.
  This is one way to tell Angular that our component's constructor requires a `HeroService` 
  so it can get the list of heroes to display. We'll get to dependency injection in a moment.
  * `providers` - 一个数组，包含组件所依赖的用于提供服务的 *依赖注入供应者* 。 
  这是我们让Angular知道组件的构造器需要一个`HeroService`服务的方式之一。这让组件能获得英雄的列表数据，并显示出来。
  接下来我们就开始讲依赖注入。
figure
  img(src="/resources/images/devguide/architecture/template-metadata-component.png" alt="元数据" align="left" style="height:200px; margin-left:-40px;margin-right:10px" )
:marked
  The `@Component` function takes the configuration object and turns it into metadata that it attaches
  to the component class definition. Angular discovers this metadata at runtime and thus knows how to do "the right thing".
  
  `@Component`函数接收一个配置对象，并且把它转换为元数据，附加到组件类的定义上。
  Angular在运行期间会发现这个元数据，并且据此了解到该如何“做正确的事”。
  
  The template, metadata, and component together describe the view.
  
  模板、元数据和组件加在一起描绘这个视图。

  We apply other metadata decorators in a similar fashion to guide Angular behavior. 
  The `@Injectable`, `@Input`, `@Output`, `@RouterConfig` are a few of the more popular decorators
  we'll master as our Angular knowledge grows.
  
  我们也会用类似的方式，通过其它的元数据装饰器来指导Angular的行为。
  `@Injectable`、`@Input`、`@Output`、`@RouterConfig`是一些最常用的装饰器。
  随着Angular知识的逐步增长，我们将逐步掌握它们。
<br clear="all">
:marked
  The architectural take-away is that we must add metadata to our code
  so that Angular knows what to do.
  
  架构所决定的是：我们必须在代码中添加元数据，以便Angular知道该做什么。

.l-main-section
<a id="data-binding"></a>
:marked
  ## Data Binding
  ## 数据绑定
  Without a framework, we would be responsible for pushing data values into the HTML controls and turning user responses
  into actions and value updates. Writing such push/pull logic by hand is tedious, error-prone and a nightmare to
  read as the experienced jQuery programmer can attest.
  
  如果没有框架，我们就需要自己把数据值推送到HTML控件中，并且把用户的反馈转换成动作并更新值。
  如果手动写实现这些推/拉逻辑的代码，肯定会枯燥乏味、容易出错、很难读懂 —— 有经验的jQuery程序员大概对此深有体会。
figure
  img(src="/resources/images/devguide/architecture/databinding.png" alt="数据绑定" style="width:220px; float:left; margin-left:-40px;margin-right:20px" )
:marked
  Angular supports **data binding**, 
  a mechanism for coordinating parts of a template with parts of a component.
  We add binding markup to the template HTML to tell Angular how to connect both sides.
  
  Angular支持 **数据绑定** ，一种让模板片段与组件片段相互合作的机制。
  我们往模板HTML中添加绑定标记，来告诉Angular如何连接两者。
  
  There are four forms of data binding syntax. Each form has a direction - to the DOM, from the DOM, or in both directions -
  as indicated by the arrows in the diagram.
  
  数据绑定的语法有四种形式。每种形式都具有方向 —— 从DOM来、到DOM去、双向，就像图中的箭头所表示那样。
<br clear="all">
:marked
  We saw three forms of data binding in our [example](#template) template:
  
  在[范例](#template)模板中，我们看到了数据绑定的三种形式：
+makeExample('architecture/ts/app/hero-list.component.1.html', 'binding', 'app/hero-list.component.html (节选)')(format=".")
:marked
  * The {{hero.name}} "[interpolation](displaying-data.html#interpolation)" 
  displays the component's `hero.name` property value within the `<div>` tags.
  * {{hero.name}} "[插值表达式](displaying-data.html#interpolation)"在`<div>`标签中显示了组件的`hero.name`属性的值。 
  
  * The `[hero]` [property binding](template-syntax.html#property-binding) passes the `selectedHero` from
  the parent `HeroListComponent` to the `hero` property of the child `HeroDetailComponent`.
  * `[hero]`[属性绑定](template-syntax.html#property-binding)把父组件`HeroListComponent`的`selectedHero`传到子组件`HeroDetailComponent`的`hero`属性中。
  
  * The `(click)` [event binding](user-input.html#click) calls the Component's `selectHero` method when the user clicks
  on a hero's name
  * `(click)`[事件绑定](user-input.html#click)

  **Two-way data binding** is an important fourth form
  that combines property and event binding in a single notation using the `ngModel` directive. 
  We didn't have a two-way binding in the `HeroListComponent` template; 
  here's an example from the `HeroDetailComponent` template (not shown):
  
  **双向数据绑定** 是很重要的第四种绑定形式，它在`ngModel`指令这个单一的标记中同时实现了属性绑定和事件绑定的功能。
  在`HeroListComponent`模板中，没有双向绑定；下面是一个`HeroDetailComponent`模板中的范例(未显示)：

+makeExample('architecture/ts/app/hero-detail.component.html', 'ngModel')(format=".")
:marked
  In two-way binding, a data property value flows to the input box from the component as with property binding.
  The user's changes also flow back to the component, resetting the property to the latest value,
  as with event binding.
  
  在双向绑定中，组件中表示数据的属性值会由属性绑定传给输入框。用户的修改也会传回组件，通过事件绑定把最近的值传给属性。
  
  Angular processes *all* data bindings once per JavaScript event cycle, 
  depth-first from the root of the application component tree. 
  
  Angular在每次JavaScript事件周期中处理一次 *所有的* 数据绑定，从组件树的根部开始进行深度优先遍历。
figure
  img(src="/resources/images/devguide/architecture/component-databinding.png" alt="数据绑定" style="float:left; width:300px; margin-left:-40px;margin-right:10px" )
:marked
  We don't know all the details yet
  but it's clear from these examples that data binding plays an important role in communication 
  between a template and its component ...
  
  虽然我们还没看懂所有细节，但从这些范例中，至少明白了一点：数据绑定在模板与相应组件的通讯中扮演了一个很重要的角色。
<br clear="all">  
figure
  img(src="/resources/images/devguide/architecture/parent-child-binding.png" alt="父/子绑定" style="float:left; width:300px; margin-left:-40px;margin-right:10px" )
:marked
  ... ***and*** between parent and child components
  
  ... ***并且*** 在父组件和子组件之间。
<br clear="all">

.l-main-section
<a id="directive"></a>
:marked
  ## The Directive
  ## 指令
figure
  img(src="/resources/images/devguide/architecture/directive.png" alt="父与子" style="float:left; width:150px; margin-left:-40px;margin-right:10px" )
:marked
  Our Angular templates are *dynamic*. When Angular renders them, it transforms the DOM 
  according to the instructions given by a **directive**.
  
  我们的Angular模板是 *动态的* 。当Angular渲染它们时，它根据 **指令** 所提供的操作指南去转换DOM。
  
  A directive is a class with directive metadata. In TypeScript we'd apply the `@Directive` decorator
  to attach metadata to the class.
  
  指令是一个带有“指令元数据”的类。在TypeScript中，我们得通过`@Directive`装饰器把元数据附加到类上。
<br clear="all">
:marked
  We already met one form of directive: the component. A component is a *directive-with-a-template*
  and the `@Component` decorator is actually a `@Directive` decorator extended with template-oriented features.
  
  我们已经遇到了指令的一种形式：组件。组件是一个 *带模板的指令* ，而且`@Component`装饰器实际上就是一个`@Directive`装饰器，只是扩展出了面向模板的属性。

.l-sub-section
  :marked
    While the **component is technically a directive**, 
    it is so distinctive and central to Angular applications that we chose
    to separate the component from the directive in our architectural overview.
    
    虽然 **组件从技术角度上说就是一个指令** ，它与众不同，而且在Angular位于中心地位，所以我们选择把它和指令分开画在我们的架构视图中。
:marked
  There are two *other* kinds of directives as well that we call "structural" and "attribute" directives.
  
  有两个 *其它* 类型的指令，我们称之为“结构型”和“属性型”指令。
  
  They tend to appear within an element tag like attributes, 
  sometimes by name but more often as the target of an assignment or a binding.
  
  它们倾向于出现在元素标签中，比如属性（也有时是元素名），但通常还是作为赋值或绑定的目标。
  
  **Structural** directives alter layout by adding, removing, and replacing elements in DOM.
  
  **结构型指令** 通过在DOM中添加、移除和替换元素来修改布局。
  
  We see two built-in structural directives at play in our [example](#template) template:
  
  我们在[范例](#template)模板中会看到两个内置的结构型指令。
+makeExample('architecture/ts/app/hero-list.component.1.html', 'structural')(format=".")
:marked
  * [`*ngFor`](displaying-data.html#ngFor) tells Angular to stamp out one `<div>` per hero in the `heroes` list.
  * [`*ngFor`](displaying-data.html#ngFor)告诉Angular为`heroes`列表中的每个英雄生成一个`<div>`标签。
  * [`*ngIf`](displaying-data.html#ngIf) includes the `HeroDetail` component only if a selected hero exists.
  * [`*ngIf`](displaying-data.html#ngIf)表示只有在已经选择了一个英雄时才会包含`HeroDetail`组件。
  
  **Attribute** directives alter the appearance or behavior of an existing element. 
  In templates they look like regular HTML attributes, hence the name.
  
  **属性型指令** 修改一个现有元素的外观或行为。在模板中，他们看起来就像是标准的HTML属性，故名。
  
  The `ngModel` directive, which implements two-way data binding, is an example of an attribute directive.
  
  `ngModel`指令是一个属性型指令的范例，它实现了双向数据绑定。
+makeExample('architecture/ts/app/hero-detail.component.html', 'ngModel')(format=".")
:marked
  It modifies the behavior of an existing element (typically an `<input>`) 
  by setting its display value property and responding to change events.
  
  它修改了现有元素（`<input>`就是典型）的行为，让它显示属性值，并从修改事件中得到回应。
  
  Angular ships with a few other directives that either alter the layout structure 
  (e.g. [ngSwitch](template-syntax.html#ngSwitch))
  or modify aspects of DOM elements and components 
  (e.g. [ngStyle](template-syntax.html#ngStyle) and [ngClass](template-syntax.html#ngClass)).
  
  Angular内置了少量其它指令，或者修改结构布局（如[ngSwitch](template-syntax.html#ngSwitch)）或修改DOM元素和组件的各个方面
  （比如[ngStyle](template-syntax.html#ngStyle)和[ngClass](template-syntax.html#ngClass)）。
  
  And of course we can write our own directives.
  
  而且，当然，我们还能写自己的指令。

.l-main-section
<a id="service"></a>
:marked
  ## The Service
  ## 服务
figure
  img(src="/resources/images/devguide/architecture/service.png" alt="服务" style="float:left; margin-left:-40px;margin-right:10px" )
:marked
  "Service" is a broad category encompassing any value, function or feature that our application needs.
  
  “服务”分为很多种，包括：值、函数，以及应用所需的任何特性。
  
  Almost anything can be a service. 
  A service is typically a class with a narrow, well-defined purpose. It should do something specific and do it well.
  
  几乎任何东西都能是一个服务。
  服务是一个典型的类，具有专注的、定义良好的用途。它应该做一些指定的事，并且做好。
<br clear="all">
:marked
  Examples include:
  例如：
  * logging service
  * 日志服务
  * data service
  * 数据服务
  * message bus
  * 消息总线
  * tax calculator
  * 税款计算器
  * application configuration
  * 应用配置
  
  There is nothing specifically *Angular* about services. Angular itself has no definition of a *service*. 
  There is no *ServiceBase* class.
  
  Angular对于服务没什么特别的要求。
  Angular自己对于服务也没有什么限定。
  Angular甚至都没有一个 *ServiceBase* 类。
  
  Yet services are fundamental to any Angular application. 
  
  即便如此，服务仍然是任何Angular应用的基础。
  
  Here's an example of a service class that logs to the browser console
  
  这里是一个“服务”类的范例，用于把日志记录到浏览器的控制台：
+makeExample('architecture/ts/app/logger.service.ts', 'class', 'app/logger.service.ts (只有类)')(format=".")
:marked
  Here's a `HeroService` that fetches heroes and returns them in a resolved [promise](http://exploringjs.com/es6/ch_promises.html). 
  The `HeroService` depends on the `LoggerService` and another `BackendService` that handles the server communication grunt work.
  
  下面是一个`HeroService`，用于获取英雄数据，并且通过一个解析的[承诺Promise](http://exploringjs.com/es6/ch_promises.html)返回它们。
  `HeroService`依赖`LoggerService`和另一个`BackendService`，用于处理服务器通讯工作。
+makeExample('architecture/ts/app/hero.service.ts', 'class', 'app/hero.service.ts (只有类)')(format=".")
:marked
  Services are everywhere. 
  
  服务无处不在。

  Our components are big consumers of services. They depend upon services to handle most chores. 
  They don't fetch data from the server, they don't validate user input, they don't log directly to the console. 
  They delegate such tasks to services.
  
  我们的组件是服务的主要消费者。它们依赖服务来处理大多数“苦差事”。
  它们不需要从服务器获得数据，它们不需要验证输入，它们不需要直接往控制台写日志。
  它们把任务委托给这些服务。
  
  A component's job is to enable the user experience and nothing more. It mediates between the view (rendered by the template)
  and the application logic (which often includes some notion of a "model").  A good component presents
  properties and methods for data binding. It delegates everything non-trivial to services.
  
  组件的任务就是提供用户体验，仅此而已。它介于视图（由模板渲染）和应用逻辑（通常包括“模型model”的观念）之间。
  设计良好的组件会提供属性和方法供数据绑定，而把那些不重要的事情都委托给服务。

  Angular doesn't *enforce* these principles. 
  It won't complain if we write a "kitchen sink" component with 3000 lines.
  
  Angular不 *强制要求* 我们遵循这些原则。
  即使我们用3000行写了一个“厨房洗碗槽”组件，它也不会抱怨什么。
  
  Angular does help us *follow* these principles by making it easy to factor our
  application logic into services and make those services available to components through *dependency injection*.
  
  Angular帮助我们 *追随* 这些原则 —— 通过让我们能更容易的把应用逻辑拆分成组件，并通过 *依赖注入* 来让这些服务可以在组件中使用。

.l-main-section
<a id="dependency-injection"></a>
:marked
  ## Dependency Injection
  ## 依赖注入
figure
  img(src="/resources/images/devguide/architecture/dependency-injection.png" alt="服务" style="float:left; width:200px; margin-left:-40px;margin-right:10px" )
:marked
  "Dependency Injection" is a way to supply a new instance of a class 
  with the fully-formed dependencies it requires. Most dependencies are services.
  Angular uses dependency injection to provide new components with the services they need.
  
  “依赖注入”是提供类的新实例的一种方式，还包括它所需的全部依赖。大多数依赖也是服务。
  Angular也使用依赖注入提供我们需要的组件，包括组件依赖的服务。
<br clear="all">
:marked
  In TypeScript, Angular can tell which services a component needs by looking at the types of its constructor parameters.
  For example, the constructor of our `HeroListComponent` needs the `HeroService`:
  
  借助TypeScript，Angular能通过查看构造函数的参数类型告诉组件需要哪些服务。
  例如，我们`HeroListComponent`组件的构造函数需要`HeroService`：
+makeExample('architecture/ts/app/hero-list.component.ts', 'ctor', 'app/hero-list.component (构造函数)')(format=".")
:marked
  When Angular creates a component, it first asks an **Injector** for
  the services that the component requires. 
  
  当Angular创建组件时，会首先为组件所需的服务找一个 **注入器Injector** 。
  
  An `Injector` maintains a container of service instances that it has previously created.
  If a requested service instance is not in the container, the injector makes one and adds it to the container
  before returning the service to Angular. 
  When all requested services have been resolved and returned, 
  Angular can call the component's constructor with those services as arguments.
  This is what we mean by *dependency injection*.
  
  注入器会维护一个服务实例的容器，存放着以前创建的实例。
  如果容器中还没有所请求的服务实例，注入器就创建一个，并且添加到容器中，然后把这个服务返回给Angular。
  当所有的服务都被解析完并返回时，Angular会以这些服务为参数去调用组件的构造函数。
  这就是我们称其为 *依赖注入* 的原因。
  
  The process of `HeroService` injection looks a bit like this:
  
  `HeroService`注入的过程看起来有点像这样：
figure
  img(src="/resources/images/devguide/architecture/injector-injects.png" alt="服务" )
:marked
  If the `Injector` doesn't have a `HeroService`, how does it know how to make one?
  
  如果注入器还没有`HeroService`，它怎么知道该如何创建一个呢？
  
  In brief, we must have previously registered a **provider** of the `HeroService` with the `Injector`.
  A provider is something that can create or return a service, typically  the service class itself.
  
  简单的说，我们必须有以前通过注入器注册过的`HeroService` **Provider**。
  Provider就是某些我们用来创建并返回服务的东西，通常是这个服务类本身。
  
  We can register providers at any level of the application component tree.
  We often do so at the root when we bootstrap the application so that
  the same instance of a service is available everywhere.
  
  我们可以在应用的组件树中的任何级别上注册Provider。
  我们通常在应用启动时注册在根组件上，以便此服务的同一个实例在任何地方都时可用的。
+makeExample('architecture/ts/app/main.ts', 'bootstrap','app/main.ts (节选)')(format=".")
:marked
  Alternatively, we might register at a component level ...
  
  或者，我们也可以注册在组件层……
+makeExample('architecture/ts/app/hero-list.component.ts', 'providers','app/hero-list.component.ts (节选)')(format=".")
:marked
  ... in which case we get a new instance of the
  service with each new instance of that component.
  
  …… 在这种情况下，那个组件的每一个新实例都会有一个本服务的新实例。
  
  We've vastly over-simplified dependency injection for this overview.
  We can learn the full story in the [Dependency Injection](dependency-injection.html) chapter.
  
  在这个概览中，我们极大的简化了依赖注入机制。
  在[依赖注入](dependency-injection.html)一章中，我们能学到关于它的全部知识。
  
  The points to remember are:
  需要记住的要点是：
  * dependency injection is wired into the framework and used everywhere.<br><br>
  * 依赖注入渗透到本框架中，并且随处可用。<br><br>
  * the `Injector` is the main mechanism.
  * 注入器是本机制的核心。
    * an injector maintains a *container* of service instances that it created.
    * 注入器负责维护一个用于存放它创建的服务实例的 *容器* 。
    * an injector can create a new service instance using a *provider*.
    * 注入器能通过 *Provider* 创建一个新的服务实例。
  * a *provider* is a recipe for creating a service.
  * *Provider* 是一个用于创建服务的“菜谱”。
 
  * we register *providers* with injectors.
  * 我们通过注入器注册 *供应者* 。

<a id="other-stuff"></a>  
.l-main-section
:marked
  ## Wrap up
  ## 总结
  We've learned just a bit about the eight main building blocks of an Angular application
  
  我们已经学到的这些只是关于应用的八个主要构造块儿的一点皮毛
  
  1. [Module](#module)   
  1. [模块Module](#module)   
  1. [Component](#component)
  1. [组件Component](#component)
  1. [Template](#template)
  1. [模板Template](#template)
  1. [Metadata](#metadata)
  1. [元数据Metadata](#metadata)
  1. [Data Binding](#data-binding)
  1. [数据绑定Data Binding](#data-binding)
  1. [Directive](#directive)
  1. [指令Directive](#directive)
  1. [Service](#service)
  1. [服务Service](#service)
  1. [Dependency Injection](#dependency-injection)
  1. [依赖注入Dependency Injection](#dependency-injection)
  
  That's a foundation for everything else in an Angular application
  and it's more than enough to get going.
  But it doesn't include everything we'll need or want to know.
    
  这是Angular应用中所有其他东西的基础，而且它已经绰绰有余了。
  但它还没有包括我们所要用的或想知道的一切。
<a id="other-stuff"></a>  
.l-main-section
:marked
  ## The Other Stuff
  ## 其他东西
  
  Here is a brief, alphabetical list of other important Angular features and services. 
  Most of them are covered in this Developers Guide (or soon will be):
  
  这里是一个简短的、按字母排序的列表，列出了其它重要的Angular特性和服务。
  它们大多数已经（或即将）包括在这个《开发人员指南》中：
  
  >**Animations** - A forthcoming animation library makes it easy for developers to animate component behavior
  without deep knowledge of animation techniques or css.
    
  >**动画Animations** - 即将到来的动画库让开发人员给组件添加动画行为变得更容易，而不需要对动画技术或css有深入了解。
  
  >**Bootstrap** - A method to configure and launch the root application component.
  
  >**启动Bootstrap** - 配置和启动应用的根组件的一种方法。
  
  >**Change Detection** - Learn how Angular decides that a component property value has changed and 
  when to update the screen. 
  Learn how it uses **zones** to intercept asynchronous activity and run its change detection strategies. 
  
  >**变更检测Change Detection** - 学会Angular如何决定组件的哪些属性值发生了变化，以及什么时候该更新到屏幕。 
  学会它如何使用 **zones** 来拦截异步行为，以及它如何运行变更检测策略。
  
  >**[Component Router](router.html)** - With the Component Router service, users can navigate a multi-screen application 
  in a familiar web browsing style using URLs.
  
  >**[组件路由Component Router](router.html)** - 通过组件路由服务，可以让用户使用浏览器中熟悉的URL形式，在多屏应用之间导航。
  
  >**Events** - The DOM raises events. So can components and services. Angular offers mechanisms for
  publishing and subscribing to events including an implementation of the [RxJS Observable](https://github.com/zenparsing/es-observable) proposal.
  
  >**事件Events** - DOM能触发事件。组件和服务也能。Angular提供的事件发布与订阅机制还包括[RxJS可观察Observable](https://github.com/zenparsing/es-observable)方案的一个实现。
  
  >**[Forms](forms.html)** - Support complex data entry scenarios with HTML-based validation and dirty checking.
  
  >**[表单Forms](forms.html)** - 通过基于HTML的验证和脏检查机制支持复杂的数据输入场景。
  
  >**[HTTP](server-communication.html)** - Communicate with a server to get data, save data, and invoke server-side actions with this Angular HTTP client.
  
  >**[HTTP](server-communication.html)** - 通过这个Angular HTTP客户端，可以与服务器通讯来获得数据、保存数据和触发服务端动作。
  
  >**[Lifecycle Hooks](lifecycle-hooks.html)** - We can tap into key moments in the lifetime of a component, from its creation to its destruction, 
  by implementing the "Lifecycle Hook" interfaces.
  
  >**[生命周期钩子Lifecycle Hooks](lifecycle-hooks.html)** - 通过实现“生命周期钩子”接口，我们可以切入组件生命中的几个关键点：从创建到销毁。
  
  >**[Pipes](pipes.html)** - Services that transform values for display. 
  We can put pipes in our templates to improve the user experience. For example,
  this `currency` pipe expression,
  
  >**[管道Pipes](pipes.html)** - 服务转换值并且显示。我们可以把管道放在模板中，以增强用户体验。比如这个`currency`管道表达式，
<div style="margin-left:40px">
code-example(language="javascript" linenumbers=".").
  price | currency:'USD':true
</div>
:marked
  >displays a price of "42.33" as `$42.33`.
  
  >把"42.33"显示为`$42.33`。
  
  >**[Testing](../testing/index.html)** - Angular provides a testing library for "unit testing" our application parts as they
  interact with the Angular framework.

  >**[Testing](../testing/index.html)** - Angular提供了一个用于对我们应用中的各个部分进行“单元测试”的测试库，就像它们与Angular框架交互时一样。
