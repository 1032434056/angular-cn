include ../_util-fns

// #docregion intro
:marked
  **Dependency injection** is an important application design pattern.
  Angular has its own dependency injection framework, and
  we really can't build an Angular application without it.
  It's used so widely that almost everyone just calls it _DI_.

  **依赖注入** 是一个很重要的程序设计模式。
  Angular有自己的依赖注入框架，离开了它，我们几乎没法构建Angular应用。
  它使用的是如此广泛，以至于几乎每个人都会把它简称为 _DI_ 。
  
  In this chapter we'll learn what DI is and why we want it.
  Then we'll learn [how to use it](#angular-di) in an Angular app.
  
  在本章中，我们将学习DI是什么，以及为什么我们需要它。
  然后，我们将学习在Angular应用中该[如何使用它](#angular-di)。
// #enddocregion intro
:marked
  [Run the live example](/resources/live-examples/dependency-injection/ts/plnkr.html)
  
  [运行鲜活范例](/resources/live-examples/dependency-injection/ts/plnkr.html)
// #docregion why-1
<a id="why-di"></a>
.l-main-section
:marked
  ## Why dependency injection?
  ## 为什么需要依赖注入？

  Let's start with the following code.
  
  我们从下列代码开始：
// #enddocregion why-1
+makeExample('dependency-injection/ts/app/car/car-no-di.ts', 'car', 'app/car/car.ts (没有 DI)')
// #docregion why-2
- var lang = current.path[1]
- var prefix = lang == 'dart' ? '' : 'this.'
:marked
  Our `Car` creates everything it needs inside its constructor.
  What's the problem?
  
  我们的`Car`类会在它的构造函数中亲自创建所需的每样东西。
  问题何在？

  The problem is that our `Car` class is brittle, inflexible, and hard to test.
  
  问题是，我们这个`Car`类过于脆弱、缺乏弹性并且难以测试。

  Our `Car` needs an engine and tires. Instead of asking for them,
  the `Car` constructor creates its own copies by "new-ing" them from
  the very specific classes, `Engine` and `Tires`.

  我们的汽车（`Car`）类需要一个引擎（`Engine`）和轮胎（`Tires`），它没有去请求一个现成的实例，
  而是在构造函数中用具体的类`Engine`和`Tires`新创建了一份只给自己用的副本。
  
  What if the `Engine` class evolves and its constructor requires a parameter?
  Our `Car` is broken and stays broken until we rewrite it along the lines of
  `#{prefix}engine = new Engine(theNewParameter)`.
  We didn't care about `Engine` constructor parameters when we first wrote `Car`.
  We don't really care about them now.
  But we'll *have* to start caring because
  when the definion of `Engine` changes, our `Car` class must change.
  That makes `Car` brittle.
  
  如果`Engine`类升级了，并且它的构造函数要求传入一个参数了怎么办？
  我们这个`Car`类就被破坏了，并且直到我们把创建代码重写为`#{prefix}engine = new Engine(theNewParameter)`之前，它都坏着。
  当我们首次写`Car`类时，我们不会在乎`Engine`构造函数的参数。其实现在我们也不想在乎。
  但当`Engine`类的定义发生变化时，我们就不得不在乎了，`Car`类也不得不跟着改变。
  这就会让`Car`类过于脆弱。

  What if we want to put a different brand of tires on our `Car`? Too bad.
  We're locked into whatever brand the `Tires` class creates. That makes our `Car` inflexible.
  
  如果我们想在我们的`Car`上用一个不同品牌的轮胎会怎样？太糟了。
  我们被锁死在了`Tires`类创建时使用的那个品牌上。这让我们的`Car`类缺乏弹性。

  Right now each new car gets its own engine. It can't share an engine with other cars.
  While that makes sense for an automobile engine,
  we can think of other dependencies that should be shared, such as the onboard
  wireless connection to the manufacturer's service center. Our `Car` lacks the flexibility
  to share services that have been created previously for other consumers.
  
  现在，每辆车都有它自己的引擎。它不能和其它车辆共享引擎。
  虽然这对于汽车来说还算可以理解，但是我们设想一下那些应该被共享的依赖，比如到厂家服务中心的车载无线（译注：汽车的一种设备，用于联系厂家）。
  我们的车缺乏必要的弹性，来共享当初给其他消费者创建的车载无线。

  When we write tests for our `Car` we're at the mercy of its hidden dependencies.
  Is it even possible to create a new `Engine` in a test environment?
  What does `Engine`itself depend upon? What does that dependency depend on?
  Will a new instance of `Engine` make an asynchronous call to the server?
  We certainly don't want that going on during our tests.
  
  当我们给`Car`类写测试的时候，我们得自己摆弄它那些隐藏的依赖。
  你以为能在测试环境中成功创建一个新的`Engine`吗？
  `Engine`自己又依赖什么？那些依赖本身又依赖什么？
  `Engine`的新实例会发起一个到服务器的异步调用吗？
  我们当然不想在测试期间这么一层层追下去。

  What if our `Car` should flash a warning signal when tire pressure is low?
  How do we confirm that it actually does flash a warning
  if we can't swap in low-pressure tires during the test?
  
  如果我们的`Car`应该在轮胎气压低的时候闪一个警示灯该怎么办？
  如果我们没法在测试期间换上一个低气压的轮胎，我们该如何确认它确实能正确的闪警示灯？

  We have no control over the car's hidden dependencies.
  When we can't control the dependencies, a class becomes difficult to test.
  
  我们没法控制这辆车背后隐藏的依赖。
  而如果我们不能控制这些依赖，类就会变得难于测试。

  How can we make `Car` more robust, flexible, and testable?
  
  我们该如何让`Car`更强壮、有弹性以及可测试？

  That's super easy. We change our `Car` constructor to a version with DI:
  
  答案超级简单。我们把`Car`的构造函数改造成使用DI的版本：

  <a id="ctor-injection"></a>
// #enddocregion why-2
+makeTabs(
  'dependency-injection/ts/app/car/car.ts, dependency-injection/ts/app/car/car-no-di.ts',
  'car-ctor, car-ctor',
  'app/car/car.ts (使用DI的代码节选), app/car/car.ts (不用DI的代码节选)')(format=".")
// #docregion why-3-1
:marked
  See what happened? We moved the definition of the dependencies to the constructor.
  Our `Car` class no longer creates an engine or tires.
  It just consumes them.
  
  发生了什么？我们把依赖的定义移到了构造函数中。
  我们的`Car`类不再创建引擎或者轮胎。
  它仅仅“消费”它们。（译注：指直接使用成品）
// #enddocregion why-3-1
// TypeScript only
.l-sub-section
  :marked
    We also leverage TypeScript's constructor syntax for declaring parameters and properties simultaneously.
    
    我们还借助了TypeScript的构造语法来同时定义参数和属性。
// #docregion why-3-2
:marked
  Now we create a car by passing the engine and tires to the constructor.
  
  现在，我们通过往构造函数中传入引擎和轮胎来创建一辆车。
// #enddocregion why-3-2
- var stylePattern = { otl: /(new Car.*$)/gm };
+makeExample('dependency-injection/ts/app/car/car-creations.ts', 'car-ctor-instantiation', '', stylePattern)(format=".")
// #docregion why-4
:marked
  How cool is that?
  The definition of the engine and tire dependencies are
  decoupled from the `Car` class itself.
  We can pass in any kind of engine or tires we like, as long as they
  conform to the general API requirements of an engine or tires.
  
  酷！引擎和轮胎这两个依赖的定义从`Car`类本身解耦开了。
  只要喜欢，我们就可以传入任何类型的引擎或轮胎，只要它们能满足引擎或轮胎的普遍API需求。

  If someone extends the `Engine` class, that is not `Car`'s problem.
  
  如果有人扩展了`Engine`类，那就不再是`Car`类的烦恼。
// #enddocregion why-4
// Must copy the following, due to indented +make.
.l-sub-section
  :marked
    The _consumer_ of `Car` has the problem. The consumer must update the car creation code to
    something like this:
    
    `Car`的 _消费者_ 也有这个问题。消费者必须更新创建这辆车的代码，就像这样：

  - var stylePattern = { otl: /(new Car.*$)/gm };
  +makeExample('dependency-injection/ts/app/car/car-creations.ts', 'car-ctor-instantiation-with-param', '', stylePattern)(format=".")

  :marked
    The critical point is this: `Car` itself did not have to change.
    We'll take care of the consumer's problem soon enough.
    
    这里的要点是：`Car`本身不必变化。我们很快就来解决消费者的问题。
// #docregion why-6
:marked
  The `Car` class is much easier to test because we are in complete control
  of its dependencies.
  We can pass mocks to the constructor that do exactly what we want them to do
  during each test:
  
  `Car`类非常容易测试，因为我们现在对它的依赖有了完全的控制权。
  我们可以往构造函数中传入mock对象，在每个测试期间，它们可以做到我们想让它们做的事：
// #enddocregion why-6
- var stylePattern = { otl: /(new Car.*$)/gm };
+makeExample('dependency-injection/ts/app/car/car-creations.ts', 'car-ctor-instantiation-with-mocks', '', stylePattern)(format=".")
// #docregion why-7
:marked
  **We just learned what dependency injection is**.
  
  **我们刚刚学过什么是依赖注入**

  It's a coding pattern in which a class receives its dependencies from external
  sources rather than creating them itself.
  
  它是一个编程模式，该模式可以让一个类从外部源中获得它的依赖，而不必自己创建它们。

  Cool! But what about that poor consumer?
  Anyone who wants a `Car` must now
  create all three parts: the `Car`, `Engine`, and `Tires`.
  The `Car` class shed its problems at the consumer's expense.
  We need something that takes care of assembling these parts for us.
  
  酷！但是，可怜的消费者怎么办？
  那些希望得到一个`Car`的人们现在必须创建所有这三部分了：`Car`、`Engine`和`Tires`。
  `Car`类把它的快乐建立在了消费者的痛苦之上。
  我们需要某种机制把这三个部分装配好。

  We could write a giant class to do that:
  
  我们可以写一个巨型类来做这件事：
// #enddocregion why-7
+makeExample('dependency-injection/ts/app/car/car-factory.ts', null, 'app/car/car-factory.ts')
// #docregion why-8
:marked
  It's not so bad now with only three creation methods.
  But maintaining it will be hairy as the application grows.
  This factory is going to become a huge spiderweb of
  interdependent factory methods!
  
  现在只需要三个创建方法，这还不算太坏。
  但是当应用规模变大之后，维护它将变得惊险重重。
  这个工厂类将变成一个由相互依赖的工厂方法构成的矩形蜘蛛网。

  Wouldn't it be nice if we could simply list the things we want to build without
  having to define which dependency gets injected into what?
  
  如果我们能简单的列出我们想建造的东西，而不用定义要把哪些依赖注入哪些对象，是不是会很美妙？

  This is where the dependency injection framework comes into play.
  Imagine the framework had something called an _injector_.
  We register some classes with this injector, and it figures out how to create them.
  
  到了让依赖注入框架一展身手的时候了！
  想象框架中有一个叫做 _注入器（injector）_ 的东西。
  我们使用这个注入器注册一些类，还会指出该如何创建它们。

  When we need a `Car`, we simply ask the injector to get it for us and we're good to go.
  
  当我们需要一个`Car`时，就简单的请求注入器取得它，然后直接去提车。
// #enddocregion why-8
+makeExample('dependency-injection/ts/app/car/car-injector.ts','injector-call')(format=".")
// #docregion why-9
:marked
  Everyone wins. The `Car` knows nothing about creating an `Engine` or `Tires`.
  The consumer knows nothing about creating a `Car`.
  We don't have a gigantic factory class to maintain.
  Both `Car` and consumer simply ask for what they need and the injector delivers.
  
  多方皆赢的方式。`Car`不需要知道如何创建`Engine`和`Tires`的任何事。
  消费者不知道如何创建`Car`的任何事。
  我们不需要一个巨大的工厂类来维护它们。
  `Car`和消费者只要简单的说出它们想要什么，注入器就会交付给它们。

  This is what a **dependency injection framework** is all about.
  
  这就是关于 **依赖注入框架** 的一切。

  Now that we know what dependency injection is and appreciate its benefits,
  let's see how it is implemented in Angular.
  
  现在，我们知道了依赖注入是什么，以及它的优点是什么。我们再来看看它在Angular中是怎么实现的。
// #enddocregion why-9
// #docregion di-1
<a id="angular-di"></a>
.l-main-section
:marked
  ## Angular dependency injection
  ## Angular依赖注入

  Angular ships with its own dependency injection framework. This framework can also be used
  as a standalone module by other applications and frameworks.
  
  Angular自带了它自己的依赖注入框架。此框架也能被当做独立模块用于其它应用和框架中。

  That sounds nice. What does it do for us when building components in Angular?
  Let's see, one step at a time.
  
  看起来很美。当我们在Angular中构建组件的时候，它能为我们做什么？
  让我们看看，一次一步儿。

  We'll begin with a simplified version of the `HeroesComponent`
  that we built in the [The Tour of Heroes](../tutorial/).
  
  我们从曾在[英雄指南](../tutorial/)中构建过的`HeroesComponent`的一个简化版本开始。
// #enddocregion di-1
+makeTabs(
  `dependency-injection/ts/app/heroes/heroes.component.1.ts,
  dependency-injection/ts/app/heroes/hero-list.component.1.ts,
  dependency-injection/ts/app/heroes/hero.ts,
  dependency-injection/ts/app/heroes/mock-heroes.ts`,
  'v1,,,',
  `app/heroes/heroes.component.ts,
  app/heroes/hero-list.component.ts,
  app/heroes/hero.ts,
  app/heroes/mock-heroes.ts`)
// #docregion di-2
:marked
  The `HeroesComponent` is the root component of the *Heroes* feature area.
  It governs all the child components of this area.
  Our stripped down version has only one child, `HeroListComponent`,
  which displays a list of heroes.
  
  `HeroesComponent`是 *英雄* 特性分区中的根组件。它管理着本分区的所有子组件。
  我们简化后的版本只有一个子组件`HeroListComponent`，它显示一个英雄列表。
// #enddocregion di-2
// #docregion di-3
:marked
  Right now `HeroListComponent` gets heroes from `HEROES`, an in-memory collection
  defined in another file.
  That may suffice in the early stages of development, but it's far from ideal.
  As soon as we try to test this component or want to get our heroes data from a remote server,
  we'll have to change the implementation of `heroes` and
  fix every other use of the `HEROES` mock data.
  
  现在`HeroListComponent`从`HEROES`获得英雄数据，一个在另一个文件中定义的内存数据集。
  它在开发的早期阶段可能还够用，但离完美就差得远了。
  一旦我们开始测试此组件，或者想从远端服务器获得英雄数据，我们将不得不修改`heroes`的实现，并要修改每个用到了`HEROES`模拟数据的地方。

  Let's make a service that hides how we get hero data.
  
  我们来制作一个服务，来把获取英雄数据的代码封装起来。
// #enddocregion di-3

// Unnecessary for Dart
.l-sub-section
  :marked
    Write this service in its own file. See [this note](#forward-ref) to understand why.
    
    把这个服务写在一个独立的文件中。参见[这里的说明](#forward-ref)来理解为什么要这样。
+makeExample('dependency-injection/ts/app/heroes/hero.service.1.ts',null, 'app/heroes/hero.service.ts' )
// #docregion di-4
:marked
  Our `HeroService` exposes a `getHeroes` method that returns
  the same mock data as before, but none of its consumers need to know that.
  
  我们的`HeroService`暴露了`getHeroes`方法，用于返回跟以前一样的模拟数据，但是它的消费者不需要了解这一点。
// #enddocregion di-4
// #docregion di-5
.l-sub-section
  :marked
    We aren't even pretending this is a real service.
    If we were actually getting data from a remote server, the API would have to be asynchronous,
    perhaps returning
    [ES2015 promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).
    We'd also have to rewrite the way components consume our service.
    This is important in general, but not to our current story.
    
    我们甚至不能说这是一个真实的服务。
    如果我们真的从一个远端服务器获取数据，这个API必须是异步的，可能得返回
    [ES2015 承诺（Promise）](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)。
// #enddocregion di-5
// #docregion di-6
:marked
  A service is nothing more than a class in Angular 2.
  It remains nothing more than a class until we register it with an Angular injector.
  
  在Angular 2中，服务其实只不过是一个类。
  除非我们把它注册进一个Angular注入器，否则它没有任何特别之处。
// #enddocregion di-6
// #docregion di-configure-injector-1
:marked
  ### Configuring the injector
  ### 配置注入器

  <a id="bootstrap"></a>
  We don't have to create an Angular injector.
  Angular creates an application-wide injector for us during the bootstrap process.
  
  <a id="bootstrap"></a>
  我们并不需要自己创建一个Angular注入器。
  Angular在启动期间会自动为我们创建一个应用级注入器。
// #enddocregion di-configure-injector-1
+makeExample('dependency-injection/ts/app/main.ts', 'bootstrap', 'app/main.ts (节选)')(format='.')
// #docregion di-configure-injector-2
:marked
  We do have to configure the injector by registering the **providers**
  that create the services our application requires.
  We'll explain what [providers](#providers) are later in this chapter.
  Before we do, let's see an example of provider registration during bootstrapping:
  
  我们必须先注册 **Provider** 来配置好注入器，这在创建应用所需的服务时会用到。
  我们将在本章的稍后部分解释什么是[Provider](#providers)。
  在此之前，我们先来看一个启动期间的注册Provider的例子。
// #enddocregion di-configure-injector-2
+makeExample('dependency-injection/ts/app/main.1.ts', 'bootstrap')(format='.')
// #docregion di-configure-injector-3
:marked
  The injector now knows about our `HeroService`.
  An instance of our `HeroService` will be available for injection across our entire application.
  
  注入器现在知道了我们的`HeroService`类。
  这样，一个`HeroService`实例就可以在我们整个应用中都可用了。

  Of course we can't help wondering about that comment telling us not to do it this way.
  It *will* work. It's just not a best practice.
  The bootstrap provider option is intended for configuring and overriding Angular's own
  preregistered services, such as its routing support.
  
  当然，我们不禁要问，为什么注释中告诉我们不要这么做。
  它 *能* 工作，但不是最佳实践。
  bootstrap函数的Provider选项是用来配置和改写Angular自身的预注册服务的，比如它的路由支持。

  The preferred approach is to register application providers in application components.
  Because the `HeroService` is used within the *Heroes* feature area &mdash;
  and nowhere else &mdash; the ideal place to register it is in the top-level `HeroesComponent`.
  
  首选的方式是在应用组件中注册应用级的Provider。
  因为`HeroService`是用于 *英雄* 功能区的 —— 并且没别处用它 —— 所以注册它的理想地点就是`HeroesComponent`的顶层。
// #enddocregion di-configure-injector-3
// #docregion di-register-providers-1
:marked
  ### Registering providers in a component
  ### 在组件中注册Provider
  Here's a revised `HeroesComponent` that registers the `HeroService`.
  
  这里是注册了`HeroService`的修改版`HeroesComponent`。
// #enddocregion di-register-providers-1
+makeExample('dependency-injection/ts/app/heroes/heroes.component.1.ts',null,'app/heroes/heroes.component.ts')
// #docregion di-register-providers-2
:marked
  Look closely at the `providers` part of the `@Component` metadata:
  
  仔细看`@Component`元数据中的`providers`部分：
// #enddocregion di-register-providers-2
+makeExample('dependency-injection/ts/app/heroes/heroes.component.1.ts','providers')(format='.')
// #docregion di-register-providers-3
:marked
  An instance of the `HeroService` is now available for injection in this `HeroesComponent`
  and all of its child components.
  
  现在，一个`HeroService`的实例就可以被注入到`HeroesComponent`及其全部子组件了。

  The `HeroesComponent` itself doesn't happen to need the `HeroService`.
  But its child `HeroListComponent` does, so we head there next.
  
  `HeroesComponent`本身不需要`HeroService`，但它的子组件`HeroListComponent`需要，所以我们再往下看。
// #enddocregion di-register-providers-3
// #docregion di-prepare-for-injection-1
:marked
  ### Preparing the HeroListComponent for injection
  ### 为注入准备`HeroListComponent`

  The `HeroListComponent` should get heroes from the injected `HeroService`.
  Per the dependency injection pattern, the component must ask for the service in its constructor, [as we explained
  earlier](#ctor-injection).
  It's a small change:
  
  `HeroListComponent`应该从注入进来的`HeroService`获取英雄数据。
  遵照依赖注入模式的要求，组件必须在它的构造函数中请求这些服务，[就像我们以前解释过的那样](#ctor-injection)。
  
// #enddocregion di-prepare-for-injection-1
+makeTabs(
  `dependency-injection/ts/app/heroes/hero-list.component.2.ts,
  dependency-injection/ts/app/heroes/hero-list.component.1.ts`,
  null,
  `app/heroes/hero-list.component (with DI),
   app/heroes/hero-list.component (without DI)`)
// Must copy the following, due to indented +make.
.l-sub-section
  :marked
    ### Focus on the constructor

    Adding a parameter to the constructor isn't all that's happening here.

  +makeExample('dependency-injection/ts/app/heroes/hero-list.component.2.ts', 'ctor')(format=".")

  // TypeScript only
  :marked
    We're writing in TypeScript and have followed the parameter name with a type annotation, `:HeroService`.
    The class is also decorated with the `@Component` decorator (scroll up to confirm that fact).

    When the TypeScript compiler evaluates this class, it sees the `@Component` decorator and adds class metadata
    into the generated JavaScript code. Within that metadata lurks the information that
    associates the `heroService` parameter with the `HeroService` class.

    That's how the Angular injector knows to inject an instance of the `HeroService` when it
    creates a new `HeroListComponent`.
// #docregion di-create-injector-implicitly-1
:marked
  <a id="di-metadata"></a>
  ### Creating the injector (implicitly)
  When we introduced the idea of an injector above, we showed how to create
  an injector and use it to create a new `Car`.
// #enddocregion di-create-injector-implicitly-1
+makeExample('dependency-injection/ts/app/car/car-injector.ts','injector-create-and-call')(format=".")
// #docregion di-create-injector-implicitly-2
:marked
  We won't find code like that in the Tour of Heroes or any of our other samples.
  We *could* write [code with an explicit injector](#explicit-injector) if we *had* to, but we rarely do.
  Angular takes care of creating and calling injectors
  when it creates components for us &mdash; whether through HTML markup, as in `<hero-list></hero-list>`,
  or after navigating to a component with the [router](./router.html).
  If we let Angular do its job, we'll enjoy the benefits of automated dependency injection.
// #enddocregion di-create-injector-implicitly-2
// #docregion di-singleton-services
:marked
  ### Singleton services
  Dependencies are singletons within the scope of an injector.
  In our example, a single `HeroService` instance is shared among the
  `HeroesComponent` and its `HeroListComponent` children.

  However, Angular DI is an hierarchical injection
  system, which means that nested injectors can create their own service instances.
  Learn more about that in the [Hierarchical Injectors](./hierarchical-dependency-injection.html) chapter.
// #enddocregion di-singleton-services

// Skip this for Dart, for now
// #docregion di-testing-component-1
:marked
  ### Testing the component
  We emphasized earlier that designing a class for dependency injection makes the class easier to test.
  Listing dependencies as constructor parameters may be all we need to test application parts effectively.

  For example, we can create a new `HeroListComponent` with a mock service that we can manipulate
  under test:
// #enddocregion di-testing-component-1
+makeExample('dependency-injection/ts/app/test.component.ts', 'spec')(format='.')
// #docregion di-testing-component-2
.l-sub-section
  :marked
    Learn more in [Testing](../testing/index.html).
// #enddocregion di-testing-component-2
// #docregion di-service-service-1
:marked
  ### When the service needs a service
  Our `HeroService` is very simple. It doesn't have any dependencies of its own.


  What if it had a dependency? What if it reported its activities through a logging service?
  We'd apply the same *constructor injection* pattern,
  adding a constructor that takes a `Logger` parameter.

  Here is the revision compared to the original.
// #enddocregion di-service-service-1
+makeTabs(
  `dependency-injection/ts/app/heroes/hero.service.2.ts,
  dependency-injection/ts/app/heroes/hero.service.1.ts`,
  null,
  `app/heroes/hero.service (v.2),
  app/heroes/hero.service (v.1)`)
// #docregion di-service-service-2
:marked
  The constructor now asks for an injected instance of a `Logger` and stores it in a private property called `_logger`.
  We call that property within our `getHeroes` method when anyone asks for heroes.
// #enddocregion di-service-service-2
// #docregion di-injectable-1
- var lang = current.path[1]
- var decoration = lang == 'dart' ? 'annotation' : 'decoration'
- var tsmetadata = lang == 'ts' ? 'As <a href="#di-metadata">we mentioned earlier</a>, <b>TypeScript only generates metadata for classes that have a decorator.</b>' : ''
:marked
  <a id="injectable"></a>
  ### Why @Injectable?
  Notice the `@Injectable()` #{decoration} above the service class.
  We haven't seen `@Injectable()` before.
  As it happens, we could have added it to our first version of `HeroService`.
  We didn't bother because we didn't need it then.

  We need it now... now that our service has an injected dependency.
  We need it because Angular requires constructor parameter metadata in order to inject a `Logger`. !{tsmetadata}
// #enddocregion di-injectable-1

// #docregion di-injectable-2
- var lang = current.path[1]
- var a_decorator = lang == 'dart' ? 'an annotation' : 'a decorator'
- var decorated = lang == 'dart' ? 'annotated' : 'decorated'
- var any_decorator = lang == 'dart' ? '' : 'TypeScript generates metadata for any class with a decorator, and any decorator will do.'
.callout.is-helpful
  header Suggestion: add @Injectable() to every service class
  :marked
    We recommend adding `@Injectable()` to every service class, even those that don't have dependencies
    and, therefore, do not technically require it. Here's why:
  ul(style="font-size:inherit")
    li <b>Future proofing:</b> No need to remember <code>@Injectable()</code> when we add a dependency later.
    li <b>Consistency:</b> All services follow the same rules, and we don't have to wonder why #{a_decorator} is missing.

  :marked
    Although we recommend applying `@Injectable` to all service classes, do not feel bound by it.
    Some developers prefer to add it only where needed and that's a reasonable policy too.

.l-sub-section
  :marked
    The `HeroesComponent` has an injected dependency too. Why don't we add `@Injectable()` to the `HeroesComponent`?

    We *can* add it if we really want to. It isn't necessary because
    the `HeroesComponent` is already #{decorated} with `@Component`. #{any_decorator}
// #enddocregion di-injectable-2
.callout.is-critical
  header Always include the parentheses
  :marked
    Always use `@Injectable()`, not just `@Injectable`.
    Our application will fail mysteriously if we forget the parentheses.

// #docregion logger-service-1
.l-main-section
:marked
  ## Creating and registering a logger service
  We're injecting a logger into our `HeroService` in two steps:
  1. Create the logger service.
  1. Register it with the application.

  The logger service implementation is no big deal.
// #enddocregion logger-service-1
+makeExample(
  'dependency-injection/ts/app/logger.service.ts',null, 'app/logger.service')

// Copied into Dart, due to different directory structure
:marked
  We're likely to need the same logger service everywhere in our application,
  so we put it at the root level of the application in the `app/` folder, and
  we register it in the `providers` array of the metadata for our application root component, `AppComponent`.
+makeExample('dependency-injection/ts/app/providers.component.ts','providers-logger', 'app/app.component.ts (excerpt)')
// #docregion logger-service-3
:marked
  If we forget to register the logger, Angular throws an exception when it first looks for the logger:
code-example(format, language="html").
  EXCEPTION: No provider for Logger! (HeroListComponent -> HeroService -> Logger)
// #enddocregion logger-service-3
// #docregion logger-service-4
:marked
  That's Angular telling us that the dependency injector couldn't find the *provider* for the logger.
  It needed that provider to create a `Logger` to inject into a new
  `HeroService`, which it needed to
  create and inject into a new `HeroListComponent`.

  The chain of creations started with the `Logger` provider. The *provider* is the subject of our next section.

  But wait!  What if the logger is optional?
  <a id="optional"></a>
  ### Optional dependencies

  Our `HeroService` currently requires a `Logger`. What if we could get by without a logger?
  We'd use it if we had it, ignore it if we didn't. We can do that.
// #enddocregion logger-service-4

// TypeScript only?
:marked
  First import the `@Optional()` decorator.
+makeExample('dependency-injection/ts/app/providers.component.ts','import-optional')(format='.')

// #docregion logger-service-5
- var lang = current.path[1]
- var rewrite = lang == 'dart' ? 'Just rewrite' : 'Then rewrite'
- var decorator = lang == 'dart' ? 'annotation' : 'decorator'
:marked
  #{rewrite} the constructor with the `@Optional()` #{decorator} preceding the private `_logger` parameter.
  That tells the injector that `_logger` is optional.
// #enddocregion logger-service-5
+makeExample('dependency-injection/ts/app/providers.component.ts','provider-10-ctor')(format='.')
// #docregion logger-service-6
:marked
  Be prepared for a null logger. If we don't register one somewhere up the line,
  the injector will inject `null`. We have a method that logs.
  What can we do to avoid a null reference exception?

  We could substitute a *do-nothing* logger stub so that calling methods continue to work:
// #enddocregion logger-service-6
+makeExample('dependency-injection/ts/app/providers.component.ts','provider-10-logger')(format='.')
// #docregion logger-service-7
:marked
  Obviously we'd take a more sophisticated approach if the logger were optional
  in multiple locations.

  But enough about optional loggers. In our sample application, the `Logger` is required.
  We must register a `Logger` with the application injector using *providers*,
  as we learn in the next section.
// #enddocregion logger-service-7

// #docregion providers-1
:marked
<a id="providers"></a>
.l-main-section
:marked
  ## Injector providers

  A provider *provides* the concrete, runtime version of a dependency value.
  The injector relies on **providers** to create instances of the services
  that the injector injects into components and other services.

  We must register a service *provider* with the injector, or it won't know how to create the service.

  Earlier we registered the `Logger` service in the `providers` array of the metadata for the `AppComponent` like this:
// #enddocregion providers-1
+makeExample('dependency-injection/ts/app/providers.component.ts','providers-logger')
// #docregion providers-2
- var lang = current.path[1]
- var implements = lang == 'dart' ? 'implements' : 'looks and behaves like a '
- var objectlike = lang == 'dart' ? '' : 'an object that behaves like '
- var loggerlike = lang == 'dart' ? '' : 'We could provide a logger-like object. '
:marked
  The `providers` array appears to hold a service class.
  In reality it holds an instance of the [Provider](../api/core/Provider-class.html) class that can create that service.

  There are many ways to *provide* something that #{implements} `Logger`.
  The `Logger` class itself is an obvious and natural provider &mdash; it has the right shape and it's designed to be created.
  But it's not the only way.

  We can configure the injector with alternative providers that can deliver #{objectlike} a `Logger`.
  We could provide a substitute class. #{loggerlike}
  We could give it a provider that calls a logger factory function.
  Any of these approaches might be a good choice under the right circumstances.

  What matters is that the injector has a provider to go to when it needs a `Logger`.
// #enddocregion providers-2
// #docregion providers-provide-1
:marked
  <a id="provide"></a>
// #enddocregion providers-provide-1

// Don't mention provide function in Dart
:marked
  ### The *Provider* class and *provide* function
// #docregion providers-provide-1-1
:marked
  We wrote the `providers` array like this:
// #enddocregion providers-provide-1-1
+makeExample('dependency-injection/ts/app/providers.component.ts','providers-1')
// #docregion providers-provide-2
:marked
  This is actually a short-hand expression for a provider registration that creates a new instance of the
  [Provider](../api/core/Provider-class.html) class.
// #enddocregion providers-provide-2
+makeExample('dependency-injection/ts/app/providers.component.ts','providers-2')
// #docregion providers-provide-3
// Skip for Dart, where the provide() function won't pass type checking.
:marked
  The [provide](../api/core/provide-function.html) function is the more common, friendlier way to create a `Provider`:
// #enddocregion providers-provide-3
+makeExample('dependency-injection/ts/app/providers.component.ts','providers-3')
// #docregion providers-provide-4-1
// Modified for Dart.
:marked
  In both approaches &mdash; `Provider` class and `provide` function &mdash;
  we supply two arguments.
// #enddocregion providers-provide-4-1
// #docregion providers-provide-4-2
:marked
  The first is the [token](#token) that serves as the key for both locating a dependency value
  and registering the provider.
// #enddocregion providers-provide-4-2

// Dart is different here (uses an optional parameter)
:marked
  The second is a provider definition object,
  which we can think of as a *recipe* for creating the dependency value.
  There are many ways to create dependency values... and many ways to write a recipe.
// #docregion providers-alternative-1
:marked
  <a id="class-provider"></a>
  ### Alternative class providers

  Occasionally we'll ask a different class to provide the service.
  The following code tells the injector
  to return a `BetterLogger` when something asks for the `Logger`.
// #enddocregion providers-alternative-1
+makeExample('dependency-injection/ts/app/providers.component.ts','providers-4')
// #docregion providers-alternative-2
:marked
  ### Class provider with dependencies
  Maybe an `EvenBetterLogger` could display the user name in the log message.
  This logger gets the user from the injected `UserService`,
  which happens also to be injected at the application level.
// #enddocregion providers-alternative-2
+makeExample('dependency-injection/ts/app/providers.component.ts','EvenBetterLogger')
// #docregion providers-alternative-3
:marked
  Configure it like we did `BetterLogger`.
// #enddocregion providers-alternative-3
+makeExample('dependency-injection/ts/app/providers.component.ts','providers-5')(format=".")
// #docregion providers-aliased-1
:marked
  ### Aliased class providers

  Suppose an old component depends upon an `OldLogger` class.
  `OldLogger` has the same interface as the `NewLogger`, but for some reason
  we can't update the old component to use it.

  When the *old* component logs a message with `OldLogger`,
  we want the singleton instance of `NewLogger` to handle it instead.

  The dependency injector should inject that singleton instance
  when a component asks for either the new or the old logger.
  The `OldLogger` should be an alias for `NewLogger`.

  We certainly do not want two different `NewLogger` instances in our app.
  Unfortunately, that's what we get if we try to alias `OldLogger` to `NewLogger` with `useClass`.
// #enddocregion providers-aliased-1
+makeExample('dependency-injection/ts/app/providers.component.ts','providers-6a')(format=".")
// #docregion providers-aliased-2
:marked
  The solution: Alias with the `useExisting` option.
// #enddocregion providers-aliased-2
+makeExample('dependency-injection/ts/app/providers.component.ts','providers-6b')(format=".")
// #docregion providers-value-1
<a id="value-provider"></a>
:marked
  ### Value providers
// #enddocregion providers-value-1

// Typescript only
:marked
  Sometimes it's easier to provide a ready-made object rather than ask the injector to create it from a class.
+makeExample('dependency-injection/ts/app/providers.component.ts','silent-logger')(format=".")
:marked
  Then we register a provider with the `useValue` option,
  which makes this object play the logger role.
+makeExample('dependency-injection/ts/app/providers.component.ts','providers-7')(format=".")

// #docregion providers-factory-1
<a id="factory-provider"></a>
:marked
  ### Factory providers

  Sometimes we need to create the dependent value dynamically,
  based on information we won't have until the last possible moment.
  Maybe the information changes repeatedly in the course of the browser session.

  Suppose also that the injectable service has no independent access to the source of this information.

  This situation calls for a **factory provider**.

  Let's illustrate by adding a new business requirement:
  The HeroService must hide *secret* heroes from normal users.
  Only authorized users should see secret heroes.

  Like the `EvenBetterLogger`, the `HeroService` needs a fact about the user.
  It needs to know if the user is authorized to see secret heroes.
  That authorization can change during the course of a single application session,
  as when we log in a different user.

  Unlike `EvenBetterLogger`, we can't inject the `UserService` into the `HeroService`.
  The `HeroService` won't have direct access to the user information to decide
  who is authorized and who is not.
.l-sub-section
  :marked
    Why? We don't know either. Stuff like this happens.
:marked
  Instead the `HeroService` constructor takes a boolean flag to control display of secret heroes.
// #enddocregion providers-factory-1
+makeExample('dependency-injection/ts/app/heroes/hero.service.ts','internals', 'app/heroes/hero.service.ts (excerpt)')(format='.')
// #docregion providers-factory-2
:marked
  We can inject the `Logger`, but we can't inject the  boolean `isAuthorized`.
  We'll have to take over the creation of new instances of this `HeroService` with a factory provider.

  A factory provider needs a factory function:
// #enddocregion providers-factory-2
+makeExample('dependency-injection/ts/app/heroes/hero.service.provider.ts','factory', 'app/heroes/hero.service.provider.ts (excerpt)')(format='.')
// #docregion providers-factory-3
:marked
  Although the `HeroService` has no access to the `UserService`, our factory function does.

  We inject both the `Logger` and the `UserService` into the factory provider and let the injector pass them along to the factory function:
// #enddocregion providers-factory-3
+makeExample('dependency-injection/ts/app/heroes/hero.service.provider.ts','provider', 'app/heroes/hero.service.provider.ts (excerpt)')(format='.')
// #docregion providers-factory-4
.l-sub-section
  :marked
    The `useFactory` field tells Angular that the provider is a factory function
    whose implementation is the `heroServiceFactory`.

    The `deps` property is an array of [provider tokens](#token).
    The `Logger` and `UserService` classes serve as tokens for their own class providers.
    The injector resolves these tokens and injects the corresponding services into the matching factory function parameters.
// #enddocregion providers-factory-4
// #docregion providers-factory-5
- var lang = current.path[1]
- var anexportedvar = lang == 'dart' ? 'a constant' : 'an exported variable'
- var variable = lang == 'dart' ? 'constant' : 'variable'
:marked
  Notice that we captured the factory provider in #{anexportedvar}, `heroServiceProvider`.
  This extra step makes the factory provider reusable.
  We can register our `HeroService` with this #{variable} wherever we need it.

  In our sample, we need it only in the `HeroesComponent`,
  where it replaces the previous `HeroService` registration in the metadata `providers` array.
  Here we see the new and the old implementation side-by-side:
// #enddocregion providers-factory-5
+makeTabs(
  `dependency-injection/ts/app/heroes/heroes.component.ts,
  dependency-injection/ts/app/heroes/heroes.component.1.ts`,
  null,
  `app/heroes/heroes.component (v.3),
  app/heroes/heroes.component (v.2)`)

// #docregion tokens-1
<a id="token"></a>
.l-main-section
:marked
  ## Dependency injection tokens

  When we register a provider with an injector, we associate that provider with a dependency injection token.
  The injector maintains an internal *token-provider* map that it references when
  asked for a dependency. The token is the key to the map.

  In all previous examples, the dependency value has been a class *instance*, and
  the class *type* served as its own lookup key.
  Here we get a `HeroService` directly from the injector by supplying the `HeroService` type as the token:
// #enddocregion tokens-1
+makeExample('dependency-injection/ts/app/injector.component.ts','get-hero-service')(format='.')
// #docregion tokens-2
:marked
  We have similar good fortune when we write a constructor that requires an injected class-based dependency.
  We define a constructor parameter with the `HeroService` class type,
  and Angular knows to inject the
  service associated with that `HeroService` class token:
// #enddocregion tokens-2
+makeExample('dependency-injection/ts/app/providers.component.ts','provider-8-ctor')(format=".")
// #docregion tokens-3
:marked
  This is especially convenient when we consider that most dependency values are provided by classes.
// #enddocregion tokens-3

// #docregion tokens-non-class-deps-1
- var lang = current.path[1]
- var objectexamples = lang == 'dart' ? 'a string or list literal, or maybe a function' : 'a string, a function, or an object'
// Is function injection useful? Should we show it?
:marked
  ### Non-class dependencies

  What if the dependency value isn't a class?
  Sometimes the thing we want to inject is #{objectexamples}.
// #enddocregion tokens-non-class-deps-1

// TS/JS only
:marked
  Applications often define configuration objects with lots of small facts like the title of the application or the address of a web API endpoint.
  These configuration objects aren't always instances of a class. They tend to be object hashes like this one:
+makeExample('dependency-injection/ts/app/app.config.ts','config','app/app-config.ts (excerpt)')(format='.')

// TypeScript only?
:marked
  We'd like to make this `config` object available for injection.
  We know we can register an object with a [value provider](#value-provider).
  But what do we use for the token?
  We don't have a class to serve as a token. There is no `Config` class.

// Typescript only
<a id="interface"></a>
.l-sub-section
  :marked
    ### TypeScript interfaces aren't valid tokens

    The `CONFIG` constant has an interface, `Config`. Unfortunately, we
    cannot use a TypeScript interface as a token:
  +makeExample('dependency-injection/ts/app/providers.component.ts','providers-9a-interface')(format=".")
  +makeExample('dependency-injection/ts/app/providers.component.ts','provider-9a-ctor-interface')(format=".")
  :marked
    That seems strange if we're used to dependency injection in strongly typed languages, where
    an interface is the preferred dependency lookup key.

    It's not Angular's fault. An interface is a TypeScript design-time artifact. JavaScript doesn't have interfaces.
    The TypeScript interface disappears from the generated JavaScript.
    There is no interface type information left for Angular to find at runtime.
// end Typescript only

// #docregion tokens-opaque-1
<a id="opaque-token"></a>
- var lang = current.path[1]
- var opaquetoken = lang == 'dart' ? '<code>OpaqueToken</code>' : '<a href="../api/core/OpaqueToken-class.html"><code>OpaqueToken</code></a>'
h3 OpaqueToken
p.
  The solution is to define and use an !{opaquetoken}.
  The definition looks like this:
// #enddocregion tokens-opaque-1
+makeExample('dependency-injection/ts/app/app.config.ts','token')(format='.')
:marked
  We register the dependency provider using the `OpaqueToken` object:
+makeExample('dependency-injection/ts/app/providers.component.ts','providers-9b')(format=".")
// #docregion tokens-opaque-2
- var lang = current.path[1]
- var decorated = lang == 'dart' ? 'annotated' : 'decorated'
- var configuration = lang == 'dart' ? '' : 'configuration'
:marked
  Now we can inject the #{configuration} object into any constructor that needs it, with
  the help of an `@Inject` #{decorator} that tells Angular how to find the #{configuration} dependency value.
// #enddocregion tokens-opaque-2
+makeExample('dependency-injection/ts/app/providers.component.ts','provider-9b-ctor')(format=".")

// begin Typescript only
.l-sub-section
  :marked
    Although it plays no role in dependency injection,
    the `Config` interface supports strong typing of the configuration object within the class.
:marked
// end typescript only

// Skip for Dart (we have another example)
:marked
  Or we can provide and inject the configuration object in our top-level `AppComponent`.
+makeExample('dependency-injection/ts/app/app.component.ts','providers', 'app/app.component.ts (providers)')(format=".")
+makeExample('dependency-injection/ts/app/app.component.ts','ctor', 'app/app.component.ts (constructor)')(format=".")

// #docregion summary
.l-main-section
:marked
  ## Summary
  We learned the basics of Angular dependency injection in this chapter.
  We can register various kinds of providers,
  and we know how to ask for an injected object (such as a service) by
  adding a parameter to a constructor.

  Angular dependency injection is more capable than we've described.
  We can learn more about its advanced features, beginning with its support for
  nested injectors, in the
  [Hierarchical Dependency Injection](hierarchical-dependency-injection.html) chapter.
// #enddocregion summary

// #docregion appendix-explicit-injector-1
.l-main-section
<a id="explicit-injector"></a>
:marked
  ### Appendix: Working with injectors directly
  We rarely work directly with an injector.
  Here's an `InjectorComponent` that does.
// #enddocregion appendix-explicit-injector-1
+makeExample('dependency-injection/ts/app/injector.component.ts', 'injector', 'app/injector.component.ts')
// #docregion appendix-explicit-injector-2
:marked
  The `Injector` is itself an injectable service.

  In this example, Angular injects the component's own `Injector` into the component's constructor.
  The component then asks the injected injector for the services it wants.

  Note that the services themselves are not injected into the component.
  They are retrieved by calling `injector.get`.

  The `get` method throws an error if it can't resolve the requested service.
  We can call `getOptional` instead, which we do in one case
  to retrieve a service (`ROUS`) that isn't registered with this or any ancestor injector.

.l-sub-section
  :marked
    The technique we just described is an example of the
    [service locator pattern](https://en.wikipedia.org/wiki/Service_locator_pattern).

    We **avoid** this technique unless we genuinely need it.
    It encourages a careless grab-bag approach such as we see here.
    It's difficult to explain, understand, and test.
    We can't know by inspecting the constructor what this class requires or what it will do.
    It could acquire services from any ancestor component, not just its own.
    We're forced to spelunk the implementation to discover what it does.

    Framework developers may take this approach when they
    must acquire services generically and dynamically.
// #enddocregion appendix-explicit-injector-2

// TypeScript only? Unnecessary for Dart
.l-main-section
<a id="forward-ref"></a>
:marked
  ### Appendix: Why we recommend one class per file

  Having multiple classes in the same file is confusing and best avoided.
  Developers expect one class per file. Keep them happy.

  If we scorn this advice and, say,
  combine our `HeroService` class with the `HeroesComponent` in the same file,
  **define the component last!**
  If we define the component before the service,
  we'll get a runtime null reference error.

.l-sub-section
  :marked
    We actually can define the component first with the help of the `forwardRef()` method as explained
    in this [blog post](http://blog.thoughtram.io/angular/2015/09/03/forward-references-in-angular-2.html).
    But why flirt with trouble?
    Avoid the problem altogether by defining components and services in separate files.
